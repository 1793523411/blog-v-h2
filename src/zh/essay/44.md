---
time: 2021-03-18
icon: template
category: 面试
article: true
sidebar: auto
footer: 😁😁😁
tag:
  - 前端
---

# 牛客上一篇前端知识汇总

## HTTP 与计算机网络

### TCP/IP 协议分层管理

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png)

五层协议：

应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。

传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。

数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。

物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异


### 三次握手四次挥手机制及原因

**三次握手**

第一次握手是让服务端知道客户端具有发送能力，第二次握手是让客户端知道服务端具有接受和发送的能力，但此时服务端并不知道客户端是否收到了自己发送的消息，所以第三次握手起到了这个作用，经过了三次握手后服务端和客户端都确认了双方的接收和发送能力

不是两次是因为无法确认客户端的接受能力，大于等于三次都可以，只是再多用处不大，第三次握手是可以携带数据的，前两次不可以，因为有人想攻击服务器，在第一次握手中放了大量数据，那么服务端必定会消耗更多的时间和内存去处理这些数据，大大增加了服务端被攻击的风险

第一次握手，客户端处于close状态，服务端处理listening状态，客户端给服务端发送了一个SYN报文并指明了客户端的初始化序列号ISN，此时客户端处于SYN_SEND状态

第二次握手，服务端接收到SYN报文后，会以自己的SYN报文作为应答，并且也指定了自己的初始化序列号ISN，同时会把客户端的ISN + 1作为ACK的值，表示自己已经收到了客户端的SYN，此时服务端处于SYN_REVD状态

第三次握手，当客户端接收到SYN报文后，会发送一个ACK报文，也把ISN + 1作为ACK的值，表示客户端接收到了服务端的SYN报文，此时客户端处于establish的状态，服务端接收到ACK报文后也处于established状态，此时双方成功建立起链接

**四次挥手**

为什么链接需要三次而断开需要四次：当服务端接收到客户端的FIN报文后，发送的ACK报文还是用来应答，并不表示服务端也希望立即关闭连接，只有当服务端把所有的报文都发送完了，才会发送FIN报文，告诉客户端可以断开连接了，因此这就是需要四次挥手的原因

第一次挥手，在挥手之前，两端都处于established的状态，客户端发送一个FiN报文，用来关闭客户端到服务端的数据传输，此时客户端处于FIN_WAIT_1状态。

第二次挥手，当服务端收到FIN报文后，会发送ACK报文，并把客户端的序列号值加1作为ACK报文的序列号，表明已经收到客户端的报文了，此时服务端处于close_wait状态

第三次挥手，如果服务端同意关闭连接，则会向客户端发送一个FIN报文，并指定一个序列号，此时服务端处于LAST_ACK的状态

第四次挥手，当客户端收到ACK后，处于FIN_WAIT_2状态，待收到FIN报文时发送一个ACK报文作为应答，并且把服务端的序列号值+1作为自己的ACK报文的序列号值，是客户端处于TIME_WAIT状态，等待一段时间后会进入closed状态，当服务端接收到ACK值后，也会变为closed状态，此时连接正式关闭

### HTTP 方法

+ GET:通常用来获取资源
+ HEAD：获取资源的元信息
+ POST：提交数据，即上传数据
+ PUT：修改数据
+ DELETE：删除数据
+ CONNECT：建立连接隧道，用于代理服务器
+ OPTIONS:列出可对资源实行的请求方法，用来跨域请求
+ TRACE：追踪请求-响应的传输路径

### GET 和 POST 的区别

最直观的是语义上的区别，往细了说：

+ 从缓存角度，GET请求会被浏览器主动缓存下来，留下历史记录，而post请求不会
+ 从编码角度，get请求只能进行URL编码，只能收到ASCII字符，而POST没有限制。
+ 从参数角度，get请求一般会放到URL中，因此不安全，post请求放在请求体中，更适合传输敏感信息
+ 从幂等性角度，get是幂等性的，而post不是（幂等性是指执行相同的操作，结果也是相同的）
+ 从TCP的角度，get请求会吧请求报文一次性的发出去，而Post会分为两个TCP数据包，首先发送header部分，如果服务器响应100，然后发boy（火狐浏览器除外，她的post请求只发一个TCP包）

### HTTP 建立持久连接的意义

HTTP建立持久连接是在HTTP1.1版本中才有的，HTTP1.0通过设立头部字段来进行不同类型文件的传输，随着互联网的发展，HTTP1.0已经无法满都需求，最核心的问题就是连接问题，具体来说就是每进行一次通信都要进行建立连接，传输数据，断开连接的过程三个阶段，当一个页面引用了较多的外部文件时，这个建立连接和断开连接的过程就会增加大量的网阔开销

为了解决这个问题，http1.1版本增加了一个创建之持久连接的方法，实现了每当一个连接传输完成时，并不是马上进行关闭，而是继续复用他传输其他请求，这个链接直到浏览器或者服务器要求断开为止

### HTTP 报文的结构

http报文结构是header+body的结构，大致为起始行+头部+空行+实体

起始行对于请求报文来说是`请求方法 路径 http版本`，对于响应报文是`http版本 状态码 原因`，起始行中每两个部分之间用空格隔开，最后一个部分后面接一个换行符

不管是请求头韩式响应头，其中的字段是相当多的，牵扯到http非常多的特性，格式方面：

+ 字段名不区分大小写
+ 字段名不允许出现空格，不可以出现下划线
+ 字段名后面必须紧跟着:

空行很重要，用来区分头部和实体，如果故意在头部中间加一个空行，那么空行后面的内容会全部被视为实体

最后实体就是body部分了，请求报文对应请求体，响应报文对应响应体

### HTTP 状态码

http状态码为三位数，被分为5类：

+ 1xx表示目前是协议的中间状态，还需要后续操作
+ 2xxx表示成功状态
+ 3xx是重定向状态，资源位置发生变动，需要重新请求
+ 4xx是请求报文有误
+ 5xx是服务端发生错误

常见的状态码有这些：

+ 200表示成功的状态码
+ 204表示请求成功但响应头后没有body数据
+ 206表示部分内容，使用场景为http分块下载和断点续传，当然也会带上相应的响应头部字段Content-Range
+ 301永久重定向，302临时重定向
+ 304表示命中协商缓存
+ 400笼统的提示一下，并不知道哪里出错了
+ 403表示服务器禁止访问
+ 404表示未在服务器上找到资源
+ 405表示请求方法不被允许
+ 406表示资源无法满足客户端的条件
+ 408表示服务器等待时间过长
+ 409表示多个请求发生了冲突
+ 413表示请求体数据过大
+ 414表示请求行里的URL太大
+ 429表示客户端发送的请求过多
+ 431表示请求字段内容太大
+ 500表示服务器出错了，但不知道出了什么错
+ 501表示客户端请求的功能还不支持
+ 502表示服务器本身正常，但访问时出错了，具体什么错误不知道
+ 503表示服务器当前很忙，暂时无法响应服务

### Web 服务器及其组成

Web服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以处理浏览器等Web客户端的请求并返回相应响应，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载，目前最主流的三个Web服务器是Apache、 Nginx 、IIS

Web服务器有以下几个部分组成：

+ 服务器初始化部分，这部分主要完成初始化的工作，比如建立守护进程，创建TCP套接字，绑定端口，等待接收客户端的连接
+ 接收客户端请求，http1.x中以文本行的形式接收，因为请求头是以文本行的方式实现的
+ 解析客户端请求，解析出请求方法，url目标，可选的查询信息以及表单信息，如果请求方法为HEAD，则简单的返回响应首部即可；如果方法是GET，则首先返回响应首部，然后将客户端请求的URL目标文件从服务器磁盘上读取，再发送给客户端；如果是POST，则比较麻烦，首先要调用相应的CGI程序，然后将用户表单信息传给CGI程序，CGI程序根据表单内容完成相应的工作，并将结果数据返回
+ 发送响应信息后，关闭与客户端的链接

### HTTP 报文首部

### HTTP 通用首部字段

### HTTP 请求首部字段、响应首部字段、实体首部字段

### Cookie 相关首部字段

### HTTPS 与 HTTP 区别及实现方式

### Cookie 与 Session

### 基于 HTTP 的功能追加协议（SPY、WebSocket、HTTP）

### 常见的 Web 攻击分类

### TCP 与 UDP 区别

### 存储机制 localStorage、sessionStorage 与 Cookie 存储技术

### XSS 攻击及防御

### CSRF 攻击及防御

## 前端工程化

## React

## NodeJs

## 手撕代码
