---
time: 2021-03-16
icon: template
category: 面试
article: true
sidebar: auto
footer: 😁😁😁
tag:
  - 前端
---

# 牛客上一篇前端知识汇总(上)

> [原文链接](https://www.nowcoder.com/discuss/258810)
> 这篇文章等于说是在做题

## JavaScript

**原始值和引用值类型及区别**

在 JavaScript 中数据类型分两种，一类是基本类型的值，另一类是复杂数据类型，基本数据类型包括 7 种：undefined，null，boolean，string,number,bigInt,Symbol,复杂数据类型在 JavaScript 中主要是对象类型，在这之中又包含许多子类型，比如普通对象，数组，函数，Math，正则等等

然后就是存储方式，基本类型一般存的原始值，复杂数据类型一般是引用值，具体的含义就是，原始值的话，当你引用它是值拷贝的方式，一般存储在栈中，引用类型的值引用它时只是引用了一个指向它的内存地址的指针，这个指针存在栈中，这就会导致一个共享内存的问题，当把一个复杂数据类型赋值给另一个变量，由于是将其指针进行了拷贝，所以当修改其中一个对象的，所有值为这个指针的对象都会发生相应的改变

::: tip
关于数据类型这一块，还可以讲讲关于数据类型的判断，类型转换
:::

**判断数据类型 typeof、instanceof、Object.prototype.toString.call()、constructor**

typeof 适合用来判断基本数据类型，对于基本类型一般会返回对应的数据类型的字符换，而对于复杂数类型除 function 外一般会返回 Object，用 typeof 判断 function 会返回字符串 function，基本数据类型中 null 是个例外，typeof 判断 null 会返回 object，这是因为 JavaScript 中不同的对象在底层都表示为二进制，当二进制前三位全为 0 时会被判断为 object，null 的二进制表示全 0，自然前三位也是 0，typeof 就会将其判断位 Object，但这不影响 null 是基本数据类型，这只是语言本身的 bug

instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，所以这这个操作符的本质就是基于原型链查找，会沿着 left 得原型链查找，若找到了 right 就返回 true，所以 instance 实现的话大致就是在一个循环中不断获取 left 得原型，并检查是否与 right 相等，left 为对象，right 为函数，我们还可以在一个类上自定义 instanceof ，Symbol.hasInstance 用于判断某对象是否为构造器的实例,所以这样就可以在内部使用 typeof 来判断基本数据类型了

```js
class Array1 {
  static [Symbol.hasInstance](instance) {
    return typeof instance === "number";
  }
}
console.log(111 instanceof Array1);
```

Object.toString.call(),是调用了 Object 上的 toString 方法，之所以任何数据类型都可以调用该方法是因为，JavaScript 中基本数据类型会先转为包装对象，然后所有对象最终的原型指向都是 Object，所以可以调用 toString 方法，调用该方法后会返回一个[object 数据类型]的字符串，这个方法对基本数据类型和复杂数据类型都有效，这种方法的一个缺点是对于自定义对象总是返回[object Object],所以该方法常用来判断内置对象

constructor 也可以用来判断数据类型，constructor 属性返回创建此对象的数组函数的引用，不能对 null 和 undefined 使用

**类数组与数组的区别与转换**

类数组是指写法上跟数组一样，但不是数组，她的原型是 Object，而数组的原型是 Array

类数组一般有 arguments , HTMLCollection, NodeList

关于 arguments 对象，他是函数的参数对象，通过 Object.prototype.toString.call()返回的结果是[object arguments],这个对象里面有一个 calle 属性可以返回函数本身，该属性从 es5 严格模式删除了

HTMLCollection 是 html dom 对象的一个接口，这个接口包含了获取到的 DOM 元素集合，返回的类型也是类数组对象，随文档中的 dom 变化而变化

NodeList 对象是节点的集合，通常由 querySelect 返回也是一种类数组，虽然不是一个数组但可以用 for of 迭代，也是一个实时集合

关于转换类数组，因为类数组并没有自带一些数组的方法，一般可以使用 call 来借用 Array 原型链上的方法来操作，比如 slice，concat，也可以使用扩展运算符来装换

**数组的常见 API**

数组常见的 API 大致可以分为三种一种是改变数组自身的方法，然后是不改变数组自身即返回一个新数组的方法，还有就是遍历的方法

改变数组自身的方法有：push,pop,shift,unshift,reverse,splice,fill,copyWithin

不改变数组自身的方法有：slice,concat,join,toString,toLocalString(根据本地时间把 Date 对象转换为字符串),indexof,lastIndexof,includes

遍历方法有：forEach,map,some,eveny,filter,reduce,find,findIndex 还有对象原型上的一些方法 keys,values,entries

::: tip
这一块还有一些 API 的实现：map，splice,pop,push,reduce,filter
:::

**bind、call、apply 的区别**

这三个方法都是在 Function 的原型上的，都用来显示的绑定 this，call 和 reply 可以由函数调用，然后第一个参数传入要绑定的上下文，后面的参数为要传给函数参数，apply 是将后续的这些参数写入到一个数组然后作为第二个参数，call 是将这些参数一个一个的作为 call 的后续参数，所以他们两个的区别就是对传入给函数的参数的传入形式不一样，最终的效果是一样的，而 bind 并不是想刚才哪两个一样直接执行函数，他先进行显示绑定 this，然后返回一个函数，然后可以自由的去调用这个函数，传入给函数参数的形式和 call 一样

**new 的原理**

当我们执行了一个 new 操作，它内部会执行四个步骤，一是先创建一个空对象，第二是将构造函数的作用域赋值给新对象，也就是将 this 指向新对象，通过 Object 的原型上的 create 方法，第三个是执行构造函数，第四个是返回这个对象，其中若构造函数又返回一个对象那么就返回这个对象，否则返回前面创建的那个对象

**如何正确判断 this？**

关于 this 有显示绑定和隐式绑定，显示得很好判断，因为自己使用 call,apply,bind 来绑定，隐式的话若不考虑箭头函数那么 this 指向哪是由他在哪运行决定的，也就是 this 指向当前调用它的上下文，如果找不到就指向全局，而箭头函数和他很不一样的一点就是它内部 this 的执行是由他在哪里定义决定的，而不有运行时决定，也可以说她的 this 指向当前离他最近的非箭头函数的 this

举个例子，比如说，在函数里面有一个函数函数内获取 this，如果通过这个对象直接调用这个函数那么这是 this 指向这个对象，而如果把这个对象单独赋值给一个全局变量，这时 this 就指向全局，浏览器里是 window，nodejs 环境下为 global，严格模式选为 undefined

上面说了两种关于运行时决定 this 的指向，还有就是比如全局定义一个函数的，这是函数的 this 指向全局，通过构造函数 new 了一个实例，此时构造函数的 this 指向这个实例，还有比如浏览器中的监听事件 onclick，addEventListen，默认指向绑定的元素，IE 的话比较奇怪，使用 attachEvent 里面的 this 指向 undefined

还有一些比较特殊的情况，就是数组的遍历 API，第一个参数通常为回调函数，第二个参数可以显示绑定 this；还有就是函数中的 this 是不会传递的，比如函数里嵌套函数，外层函数的 this 有运行时所在的上下文决定，这个上下文不会传递给嵌套的函数，最后就是类中的 this 指向，类中的 this 指向类本身，但还是 this 有运行时的上下文决定，若将类中的方法赋值给全局变量，然后在全局进行调用，由于 class 内部默认采用严格模式，所以 this 并不会指向全局而是指向 undefined

**闭包及其作用**

闭包是基于作用域链的，是当前作用域可以访问到父级作用域，针对的是函数，一个嵌套另一个函数，当里面的函数引用了外层函数的变量就形成了当前作用域访问到了父级作用域，此时就形成了闭包，这是嵌套的函数同时保存了当前作用域和父级作用域

产生闭包一般有函数内返回返回另一个函数，函数作为参数进行传递，立即执行函数，比如 js 中经常会在 setTimeout，事件监听中中使用回调函数，这也是闭包，还有 webpack 打包后的结果是一个立即执行函数，这也是闭包

闭包的优点就是可以访问并保存父级作用域，这样就可以形成私有变量，同时由于保存了父级作用域，自然父级作用域就不会被垃圾回收，这样也会产生一个缺点就是，当这种操作很多的话，由于许多父级作用域被引用，并不会被垃圾回收，就会导致内存泄漏

闭包的另一个优点是他可以用来实现模块化，从而避免全局变量的一个污染，因为立即执行函数就为模块提供了私有空间，具体做法就是将每个模块成员都放到一个立即执行函数所形成的私有作用域中，而对于需要暴露给外部的成员，可以挂载到全局对象上，因为立即执行函数保存当前父级也就是全局作用域

还有一种模块的方式就是函数返回一个有许多函数组成的对象，这个模块其实是暴露给了全局

闭包的用途除了刚刚说的私有作用域模块化之外还有，可以实现单例模式，还有比较经典的循环里打印下标

**原型和原型链**

JavaScript 是一门基于原型的语言，原型可以分为隐式原型和显式原型，比如我声明一个空对象，这是通过 Object.getPrototypeOf()就可以获取到这个对象的隐式原型，当然也可以直接访问这个对象的**proto**,但这个不在规范中，官方也不推荐使用，显式原型的就是比如我声明一个构造函数，那么这个构造函数就有 prototype 属性指向这个构造函数的显式原型，我们是可以往这个显示原型的挂在一些方法和属性，这样通过这个构造函数 new 的实例就可以访问到这个原型上的属性，做实例的隐式原型也指向构造函数的显式原型

原型链的话就是，构造函数的原型也拥有自己的原型，同时这个原型也肯有自己的原型，这样当我们在这个构造函数的一个实例上访问一个属性，会先在自身查找，找不到去原型上查找，还找不到去原型的原型上查找，知道找到为止，所有对象的原型都会指向 Object，找到最后没找到就会报找不到的错误，这样就形成了一条原型链，属性和方法也可以基于原型链查找，这也就是为什么 Object.prototype.toString.call()，可以判断基本数据类型和复杂数据类型的原因，所有对象在其原型链上都可找到 Object，自然可以调用该方法，基本数据类型通过 Object()被转为包装对象，自然也可以调用这个方法

原型链的作用一个是属性和方法的查找，还有一个是可以用来实现基于原型链继承

**prototype 与`__proto__`的关系与区别**

实例的`__proto__`,指向构造函数的 prototype,或者说实例的隐式原型指向构造函数的显式原型

区别就是一个针对实例的，一个是针对构造函数的，`__proto__`不是标准中规范的，可以使用 Object.getProtoType()代替

**继承的实现方式及比较**

继承的实现方式大致有五种：

第一种是通过原型链来实现继承，做法就是在子类的原型上挂载一个父类实例，这样就可以访问到父类的属性和方法，这种继承的问题在于对于引用数据类型内存空间是共享的，一个实例发送改变会引起其他实力也发生改变

第二种是通过构造函数来实现继承，具体做法就是在子类面通过 call，在在子类的上下文中执行父类，这样可以解决内存空间共享的问题，因为每个子类实例都是一个新的内存空间，但这样这样做的缺点是如果父类在原型上有方法，那么子类会继承不了

将上面两种方式结合形成第三种继承方式，组合式集成，但这样带来的问题是父类的的构造函数执行了两次，一次在子类的构造函数中，另一次是在网子类原型上挂在时，造成了一次不必要的开销，一个优化是直接将父类的原型挂载到子类原型上，这样少了一次开销，但同时引入了新的问题，子类的构造函数变成了父类，正常来说应该是子类

第四种是通过对象关联这样一种形式，通过 Object.create()来基于父类的原型创建子类，这叫做原型式继承，这样做的的缺点是内存空间共享问题

使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力在进行增强就形成了寄生式继承，但依然存在内存空间共享的问题

第五种就是寄生式组合继承，在构函数里调用父类来解决内存空间共享，通过 Objec.create()来会的目标对象的一份浅拷贝，这就是最优的一种继承实现方式，既没有内存空间共享问题，也没有两次调用父类造成不必要开销的问题，并且 es6 中的 class 的 extend 也是基于这种方式实现的继承

关于继承的这几种实现代表了两种设计思想，一种通过继承的设计思想即父类子类这样，另一种是通过行为委托，并没有父子类之说，而是兄弟关系，JavaScript 的原型机制本身也就是行为委托，对象关联可以通过行为委托来实现

**深拷贝与浅拷贝**

浅拷贝就是讲一个对象拷贝给另一个对象时，对于基本数据类型，直接复制其值，对于复杂数据类型复制其指针，这就会造成修改拷贝的对象的引用数据类型，会影响到原来对象的相对应的引用数据类型，而深拷贝则是在拷贝时对于引用数据类型，完全申请了一块堆内存，将拷贝后的这个数据和原来的数据在内存上完全分离，不会出现浅拷贝那种内存空间共享的问题，深拷贝真正实现了二者的真正分离

浅拷贝的实现方式有许多，比如可以用过 Object.assign()，来实现浅拷贝，这个方法可以拷贝 Symbol 类型，但不会拷贝原型链上的和不可枚举的属性，还有一种是使用扩展运算符来实现浅拷贝，即可以对对象使用也可以对数组使用，针对数组的浅拷贝还可以使用 concat，slice

浅拷贝的一个实现思路：

```js
const copy = (obj) => {
  if (typeof obj === "object" && obj !== null) {
    const clone = Array.isArray() ? [] : {};
    for (let prop in target) {
      //for in 循环可遍历到可枚举以及原型上的属性
      if (target.hasOwnPrototy(prop)) {
        clone[prop] = obj[prop];
      }
    }
    return clone;
  } else {
    return obj;
  }
};
```

深拷贝可以通过 JSON 序列化反序列的方式来实现，但受到 json 数据格式的影响，对于一些特殊的数据不能处理，比如 undefined，Symbol，一些内置内类型比如日期和正则，日期会变成字符串，正则会变成空对象,还有不可枚举的拷贝不了，对象原型链拷贝不了，循环引用也解决不了

针对不可枚举的对象和 Symbol 可已通过 Reflect.ownKeys()方法获取，针对日期和正则直接生成一个新的实例返回，针对原型链上的属性可以通过 Object.getPropertyDescriptors 方法获得，因为他可以获得对象的所有属性，然后用 object.create(),创建一个新对象，针对循环引用可以使用 weakMap 作为一个哈希表，并且因为 weakMap 是弱引用可以避免内存泄漏

```js
const isComplexDateType(obj) => (typeof obj === "object" ||typeof obj ==="function") && obj !== null;
const copy = (obj,hash = new WeakMap()) => {
  if(obj.constructor === Date) return new Date(obj)
  if(obj.constructor === RegExp) return new RegExp(obj)
  if(hash.has(obj)) return hash.get(obj);
  let allDec = Object.getPrototyDescriptors(obj);
  let clone = Object.create(Object.getprototypeOf(obj),allDec);
  hash.set(obj,clone);
  for(let key of Reflect.ownKeys(obj)){
    clone[key] = isComplexDataType(obj[key]) && obj[key] !== "function";
    ? clone(obj[key],hash)
    :obj[key]
  }
  return clone
}
```

**防抖和节流**

略

**作用域和作用域链、执行期上下文**

作用域就是可以访问的代码中的变量和函数的范围

作用域链的作用是保证变量和函数的一个有序访问，通过作用域链，我们可以访问到外层的变量和函数，她的本质是一个指向变量对象的变量指针，变量对象包含了执行环境中的所有变量和函数，作用域链的始端指向当前作用域，终端指向全局作用域，当查找一个变量时，会现在当前作用域查找，找不到就沿着作用域链向上查找，作用域链的创建过程和执行上下文有关

执行上下文可以理解成一个对象，这个对象分三部分：变量对象，作用域链，this 指向，类型包含全局上下文，函数上下文和 eval 上下文

执行上下文其实是代码的一个执行环境，一段代码执行过程中，遇到了函数，会将函数上下文依次压入到执行占中，当函数执行完便会将这个函数上线文从执行栈中弹出，

**DOM 常见的操作方式**

dom 中的操作主要分为添加，删除，移动，复制，创建和查找

创建节点的方式主要有:createDocumentFragMent()创建一个 Dom 片段，createElement()创建一个具体的元素，createTextNode()创建一个文本节点

appendChild()添加操作，removeChild()删除操作,replaceChild()替换操作,insertBefore()插入

查找方法有:getElementById(),getElementByName(),getElementByTagName(),getElemenetByClassName(),querySeletor(),querySleectorAll()

属性操作：getAttribute(key),setAttribute(key, value),hasAttribute(key),removeAttribute()

**Array.sort()方法与实现机制**

Array,sort()，在不同的浏览器里底层是用的排序方法是不一样的，以 V8 为例，根据排序的元素个数会采用不同的排序方法：

当`n <= 10`时，采用差如排序，当 `n > 10`采用快速排序，当`10<n<=1000`,使用中位数作为哨兵元素，当`n>1000`每隔 200-215 个元素，放入到一个新数组中，对他排序，找到中间位置的数，以此作为中位数

元素少是使用插入排序因为插入排序在最好的情况下时间复杂度为 o(n),尽管平均复杂度为 o(n^2),快速排序平均复杂度为 o(nlogn),实际情况下两者的前面都一个系数，对于插入排序，若 n 足够小，速度会超过快排，插入排序在经过优化以后，对于小数据集会有非常优越的性能，所以这是选择插入排序是个不错的选择

快速排序的性能瓶颈在与递归的深度，最坏的情况是每次的哨兵都是最小的元素会最大的元素，在进行 partiton（一边是小于哨兵的元素，一边是大于哨兵的元素）那么就会有一边是空的，这么排下去递归层数就为元素的个数 n，时间复杂度会退化为 o(n^2),通过让哨兵元素尽肯能处于中间位置，减少最大或最小的情况，这就是 v8 对快速排序的一种优化

**Ajax 的请求过程**

使用 ajax 步骤大概是:

1. 创建 XMLHttpRequest 对象，这是一个异步调用对象
2. 然后创建一个新的 http 请求的方法，并指定该 HTTP 请求的方法，URL 及验证信息
3. 设置响应 http 请求状态变化的函数
4. 发送 http 请求
5. 获取异步返回的数据
6. 使用 JavaScript 和 Dom 实现局部刷新

如果是 post 可以通过`xhr.setRequestHeader("Content-type","application/x-www-from-urlencoded")`设置请求头

关于上面第三部的 http 的请求状态 readState，0 表示未初始化，1 表示服务器已建立连接，2 表示请求已收到，3 表示请求处理中，4 表示请求以完成，且响应已就绪

**JS 的垃圾回收机制**

js 中数据存储的位置有两种，一种是在栈中，另一种是在堆中，由于栈中的数据量都比较小，所以栈中的垃圾回收由操作系统来完成，js 中的垃圾回收机制只要针对的是堆内存

js 中有两个垃圾回收器，一个是副垃圾回收器，一个是主垃圾回收器，前者负责新生代中的垃圾回收，后者负责老生代中的垃圾回收

新生代中的垃圾回收机制是这样的，他主要回收哪些生命周期比较短的内存对象，所以需要一个效率非常高的算法，这个算法是一个牺牲空间来换取时间的算法，在占用空间不大的场景下非常适用，这个算法将内存分为两部分，一个 from space 一个是 to space，对 from space 中的活动对象进行标记，然后移动到 to space，并将这些对象有序的排列起来，然后将 from space 中的非活动对象进行释放，完成之后交换这两块，使得新生代中的这两块区域可以重复利用

新生代中的对象会通过晋升然后移动到老生代，在新生代中进一步划分了两个子区域，当我们第一次对内存进行分配时会被分配到其中一个子区域中，如果下一次垃圾回收这个对象还在新生代中，则会被移动到另一个子区域中，如果下一次垃圾回收这个对象还在新生代中，则这个对象会被移动到老生代

老生代中不能使用新生代中的垃圾回收算法，因为新生代中的算法为复制算法，重复复制活动对象效率低下，且是牺牲空间换时间的算法，老生带中的支持很大的容量，会出现资源浪费，所以老生代中主要使用标记清除和标记整理的算法

标记清除算法中先对老生代进行一次扫描，标记活动对象，然=然后进行第二次扫描，清理掉这些未被标记的对象，及非活动对象，这样会造成一个问题，被清除的对象遍布于各内存地址，产生了很多碎片，当需要分配一个很大的对象时，这些碎片空间无法完成分配，就会提前触发垃圾回收，而这次垃圾回收是不必要的，因此就有了标记整理的算法，他会将所有活动对象移项一端，然后直接清理掉边界外的内存

上面的垃圾回收当中当标记整理算法在移动活对象时可能对象比较多，她的执行速度不是很快，为了避免 js 的应用逻辑和垃圾回收器的资源竞争导致不一致的问题，这时垃圾回收器会将整个 JavaScript 应用暂停，这个过程叫做全停顿，而在新生代中由于空间小，存活对象较少，新生代的算法效率较快，所以全停顿并不影响，而老生带中活动对象较多，垃圾回收器全停顿的时间较长就会导致页面卡顿

为了解决上面那种卡顿 v8 通过增量标记和惰性清除，以及并发并行来降低主线程的挂在时间

增量标记就是将标记的过程穿插在 JavaScript 应用逻辑之间，允许标记的时间为 5~10ms，增量标记达到一定的阈值时才会启动，启动之后每当一定量的内存分配之后脚本的执行就会停顿进行一次增量标记

惰性清除用来真正释放内存，当增量标记完之后，加入当前的可用内存足以让我们的代码快速执行，其实我们是没有必要进行立即的清理内存的，可以将这个清理的过程延迟一下，让 js 代码先执行，也无需进行一次性的清理完所有非活动对象，垃圾回收器会逐一进行清理，直到所有都清理完毕

虽然增量标记和惰性清除是的主线程的最大停顿时间大大减少，也让用户与浏览器的交互过程流畅许多，但是每个小的标记之间执行了 js 代码堆中的变量的指针的可能发生了变化需要使用写屏障技术来保证这些引用关系的一致性，这就是增量标记的缺点：并没有减少主线程的总暂停时间甚至略微增加，由于写屏障技术机制的成本，增量标记可能会降低应用程序的吞吐量

并行式的 gc 可以使得辅助线程同时执行同样的 gc 工作，让辅助现成来分担主线程 gc 的工作，使得垃圾回收的耗时等于总时间除以参与线程的数量

目前 v8 的垃圾回收机制就是，副垃圾回收器使用并行机制，讲 from space 移动到 to space 时开启多个辅助线程，并行的进行整理，这会导致资源竞争，所以需要在每个对象复制完成后都去维护这个复制这个活动对象后的指针转发地址，以便于其他辅助线程可以找到该活动对象后判断该活动对象是否已被复制；对于主垃圾回收器，当堆中的内存大小超过阈值后，会并发的进行标记任务，每个辅助线程都会去追踪每个标记到的对象以及这个对象的引用，js 代码执行时，并发标记也会在后台的辅助线程中执行，当对象被修改时写入屏障技术会在辅助线程进行并发标记时进行追踪，当标记或动态分配的内存达到极限的时候，主线程会进行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次进行扫描确保所有对象都完成了标记，由于辅助线程已经标记过了活动对象，这次的扫描只是进行一次 check 操作，确认完成之后，有辅助线程进行内存的整理和清除，由于都是并行的，所以并不会影响主线程的执行

**JS 中的 String、Array 和 Math 方法**

String : split,slice,substr,trim,concat,indexOf ,lastIndexOf

Array:····

Math：有一些常量和一些方法，都是与数学运算有关的

**addEventListener 和 onClick()的区别**

onclick 是 Dom0 的绑定事件的方式，而 addEventLister 是 Dom2 绑定事件的方式，使用 onclick 绑定的事件解绑需要将 onclick 设为 null，而 addEventListener 绑定的事件解绑需要 removeEventListerk 来解绑

onclick 绑定事件有点有：简洁，处理事件 this 指向当前元素，缺点是不能对事件进行捕获和冒泡进行控制，只能使用事件冒泡而不能使用事件捕获，并且一次只能对一个元素绑定一个事件处理程序，当使用 window.onload 时，会覆盖采用相同方法所绑定的事件

addEventListener 的优点就是支持捕获与冒泡，通过最后一个参数来设置，默认值为 false 表示事件冒泡，设置为 true 表示事件捕获，她的 this 和 onclick 一样，事件处理函数中，event 对象总是作为第一个可用参数，可以绑定多个事件而不会发生覆盖，缺点是 ie8 不支持

**new 和 Object.create 的区别**

new 操作所做的工作有：

- 创建一个对象
- 对新对象进行原型操作，指向构造函数的原型
- 将 this 绑定到新对象上
- 如果构造函数返回了一个对象，就返回这个对象，否则返回新对象

object.create 所做的工作有：

该方法有两个参数，第一个参数作为新建对象的原型，第二个参数是一个对象，该对象的属性名称是新创建的对象的属性名称

- 创建一个新对象
- 将新对象的`__proto__`指向传入的参数
- 将传入的对象属性复制到新对象并返回新对象

从他们的内部所做的工作可以看出 new 是保留了构造函数，而 object.create()没有，原型链方面，new 保留了原构造函数的 prototype 属性，而 object.create 就是原构造函数或对象本身，new 作用的对象只能是函数，而 object.create 可以是函数也可以是对象

**DOM 的 location 对象**

window.location 是一个只读属性，返回一个 location 对象，其中包含有文档当前的位置信息，包括 hash，search,host,hostname,href,origin 等等,还有一些方法比如 reload，replace，assign

尽管他是一个只读对象，仍然可以赋值给他一个 DOMString，这意味着可以再大多数情况下处理 location，就像它是一个字符串一样：

`window.location = 'http://www.example.com'`，是 `window.location.href = 'http://www.example.com'`的同义词

reload 强制从服务器从新加载当前页面，replace 重新加载页面，assign 使用新的 url 加载页面

**浏览器从输入 URL 到页面渲染的整个流程（涉及到计算机网络数据传输过程、浏览器解析渲染过程）**

网络层面，首先，域名是对 ip 地址的映射，所以这里也有一个 DNS 解析的过程，DNS 也会存在缓存，首先是浏览器缓存，然后是系统缓存，然后是路由器缓存，然后是运营商缓存，根域名服务器，再到顶级域名服务器，主域名服务器逐一读取，DNS 的查询方式有两种一种是递归查询，从客户端到 DNS 服务器是属于递归查询的，而 DNS 服务器之间的交互查询是迭代查询，然后会建立 tcp 链接经历三次握手，然后进行 http 链接，构建请求构建请求行，`GET / HTTP/1.1`,查找强缓存，强缓存失效，使用协商缓存，得到服务端的响应，到这网络层面结束

解析层面，浏览器收到服务端传过来的 html 文件的字节流，先进行字节流的一个解码，这样才能看到字符串，然后进行输入流预处理，主要是生成规范化的字符流数据，然后是令牌化，将字符流解析成标签和文本节点，然后根据上一步的操作进行 Dom 树的构建，在这当中若遇到 script 标签会根据 script 加载的方式进行不同的处理，当 script 标签中改变了 DOM 的结构，则会将这些改变的代码加入到字符流重新进行解析，dom 树构建完会进行 CSSOM 树的构建

渲染方面，有了 cssom 树和 dom 树会计算布局，并生成布局树，然后对于一些复杂的场景比如动画，会有层叠上下文，这是会进行图层树得构建，接下来渲染引擎会将图层拆分成一个一个绘制指令，生成绘制列表，然后由合成线程进行绘制，考虑到视口很大不可能一下子绘制完，所以会对图层进行分块，渲染进程还会专门维护一个栅格化线程池专门负责把图块转换成位图数据，这个过程要进入到 GPU 当中进行加速并生成位图然后返回给合成线程，由于上传 GPU 会比较慢，chrom 采取了一个优化首屏加载速度操作，回先展示一个分辨率比较低的图片，最后显示器显示内容，合成线程生成绘制指令，发送给浏览器进程，浏览器受到这个命令把页面内容绘制到内存，也就是生成了页面，再把这部分内存发送给显卡，显卡接收到后会合成相应的图像，并将图像保存到缓冲区

所以当动画过多占用大量内存，浏览器生成图像变慢，传递给显卡不及时，显示器以不变的频率刷新，就会出现掉帧现象

**跨域、同源策略及跨域实现方式和原理**

跨域之所以出现是因为浏览器为了保证安全而制定的一个同源策略，浏览器之外是不存在跨域的，同源策略是一个域去访问另一个域中的资源是会被禁止，同源要求 ur 协议，主机名，端口都相同

解决跨域一般有四种方式：第一种是通过跨域资源共享，这种是在服务端进行解决，第二种是使用 jsonp，这种方式的缺点是只能发 get 请求，不能捕获服务端的错误，并且请求过程无法终止，是利用了浏览器对 script 标签没有同源策略的限制来实现的，第三种是通过 webscort 来解决跨域，这是因为他是个全双工协议，不是同源策略限制，最后一种是通过代理转发的方式，比如 webpack 的 devserve，nginx 配置 proxy_pass

还有一种跨域是父子页面的跨域，例如使用 iframe 来进行父子页面之间的通信，这是可以使用，postMessage 来进行通信，也可以用过改域的方式来解决，将 document.domain 改成更高的父域

**浏览器的回流（Reflow）和重绘（Repaints）**

重绘是渲染树中一些元素需要更新属性，而这些属性只影响外观，风格，不会影响布局的操作，比如背景色这样的操作成为重绘

回流当渲染树中一部分因为尺寸，规模，布局，隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称之为回流

重绘由于没有影响到布局，所以只进行了样式计算而跳过了布局树和建图层树的过程，直接生成绘制列表，然后继续进行分块，生成位图等后面一些类操作

回流会将样式计算后一系列操作重新执行一遍，开销是比较大的，并且回流一定会重绘，但重绘不一定会回流

那么避免回流可以这样组：

- 使用 transfrom 代替 top
- 进行防抖节流处理
- DOM 离线修改，使用 documentFragment 对象在内存中操作 Dom
- 避免频繁使用 style，而是使用 class
- 添加 will-change:transform,让渲染进程单独实现一个图层，仅仅利用合成线程去处理，不牵涉到主线程，大大提高渲染效率

**JavaScript 中的 arguments**

他是一个类数组，使用 typeof 返回 [object argumengt],他作为函数的参数对象，内部有 callee 返回函数本身，可以使用显示绑定 this 的方式借用数组上的方法，也可以将它转换成数组

**EventLoop 事件循环**

js 是单线程的语言，在代码执行时，通过将不同函数的执行下文压入执行栈中来保证代码的有序执行，在执行同步代码的时候遇到到了异步代码，js 引擎并不会一致等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务，当异步任务执行完毕后再将异步事件回调加入到与当前执行栈不同的另一个任务队列等待执行

任务队列可分为宏任务和微任务，当前执行栈中的函数之心完毕后会先判断为任务队列中是否有任务可以执行，如果有就将微任务队列的任务依次压入执行性栈中，当微任务执行完毕后再去判断宏任务中的队列，同时开启新的一轮事件循环

浏览器中事件循环是依靠浏览器完成的异步操作

nodejs 中底层使用 libuv 库实现多线程

以前版本的 nodejs 和浏览器的事件循环还是很不一样的，浏览器中的微任务会在每个相应宏任务中执行，而 nodejs 中微任务是在每个阶段之间执行的，当 nodejs 版本大于 11 后，nodejs 和浏览器表现一致

**宏任务与微任务**

宏任务常见的有 setTimeout，setInterval，setImmediate，requestAnimationFrame，这些事件会在开启新的一轮事件循环时去执行

微任务常见的有 Promise，MutiationObserver，process.nextTick,微任务的引入是为了解决异步回调的问题，对于异步回调 js 采取的是将异步回调放到当前宏任务的末尾，这样可以保证回调函数及时得到执行，不会造成卡顿，如果把回调函数进行宏任务的入队操作，当宏任务队列非常长的时候回调函数会迟迟得不到执行

微任务中的 Process.nextTick 是一个独立于事件循环的任务队列，每一个轮事件循环结束后回去检查这个队列，如果有，会让其优于微任务执行

**BOM 属性对象方法**

对象：Window，document，location，screen，history，navigator。

方法：Alert()，confirm()，prompt()，open()，close()

**函数柯里化及其通用封装**

函数柯里化是指将多个参数的函数装化成一系列使用一个参数的函数，一个简单的函数柯里化实现：

```js
function curry(fn, args) {
  let length = fn.length;
  args = args || [];
  return function() {
    let subArgs = args.slice(0);
    for (let i = 0; i < arguments.length; i++) {
      subArgs.push(arguments[i]);
    }
    if (subArgs.length >= length) {
      return fn.apply(this, subArgs);
    } else {
      return curry.call(this, fn, subArgs);
    }
  };
}
```

使用函数柯里化可以实现参数复用，提前返回，延迟计算或执行，js 中的 bind 是延迟函数的执行

**JS 的 map()和 reduce()方法**

map 方法主要来遍数组，返回一个新数组不会对原数组产生影响，第一个参数为回调函数，用来对数组的元素进行处理，其中回调函数的参数第一个为当前数组元素，第二个为当前下标，第三个为遍历的数组，第二参数 this 的显示绑定

reduce 方法也用来遍历数组，第一个参数为回调函数，第二个参数为初始值，回调函数的第一个参数为累机器，第二个为当前元素，第三个为当前索引，第四个为遍历的数组

**“==”和“===”的区别**

`==`在进行判断时会进行隐式的数据类型转换，而`===`在进行比较是不会进行数据类型转换

`==`的转换规则为：

- 字符串与数字比较，将字符串转为数字在比较
- 其他类型与 boolen 进行比较，先将布尔转换为数字，在应用其他规则进行比较
- null 和 undefined 比较，结果为真，他们和其他值比较均为假
- 对象和非对象进行比较，对象会进行转换的操作，然后在进行比较
- 如果有一个为 NaN,返回 false
- 若两个都是对象，判断他们是否指向同一个对象，是的话为 true，否为为 false

`Object.is()`,也可以用来进行比较，他主要是修复了一些特殊情况下的 bug，比如正 0 等于负零，NaN 不等于 NaN

**setTimeout 用作倒计时为何会产生误差？**

setTimeout 属于宏任务，如果当前执行栈的执行时间很长大于定于定时器的时间，那定时器的回调在宏任务里来不及去调用，这个时候就会产生误差，另外一种，是在上一轮事件循环中将 setTimeout 推入到宏任务队列中，若上一轮事件循环也需要很长的时间执行，也会造成误差，所以 setTimeout 的倒计时只是保证在这个倒计时之前不会被执行，但不能保证倒计时结束之后一定被执行

## ES6

**let、const 和 var 的概念与区别**

let 声明的块级作用域，而 var 声明的词法作用域，这两者都声明可变的变量，前者不可重复声明，后者可重复声明，会进行覆盖

const 也是声明的块级作用域，声明不可变得变量，不可重复声明，这里的不可变是指变量在栈中的位置不可变，对于复杂数据类型，存储在堆当中，堆中的数据是可以改变的，如果想让复杂数据类型彻底的不可变可以对对象进行冻结操作

let 和 const 会有暂时性死区，而 var 会有变量提升

**变量提升与暂时性死区**

暂时性死区是指变量只能在声明后在使用，在一个作用域中开始到声明变量，这之间的区域成为暂时性死区

变量提升是指当全局声明了一个变量会先将变量的声明提升到作用域的顶端，然后再原来的位置进行赋值，如果有的话，函数会将整个函数体放到作用域的顶端，造成变量提升的本质是 js 引擎在执行代码前有一个解析的过程，创建了执行上下文，初始化了一些执行代码需要用到的变量

**变量的结构赋值**

解构赋值分为两个步骤：变量的声明，和变量的赋值，解构赋值的本质就是模式匹配，只要等号两边模式相同，左边的变量就会被赋予右边的值，如果匹配不成功，就会被赋值为 undefined

解构分为数组的解构赋值，对象的解构赋值，对象的结构也包括比如说基本数类型的解构赋值，因为基本数据也是可以转为对象的

对于数组的解构赋值，只要某种数据具备 Ierator 接口既可以结构维数组，如果不使用默认值，不会执行默认的函数

对于对象的解构赋值，只要右边不是对象或数组，就会先转为对象，由于 undefined 和 null 都不是对象，所以对他们进行解构赋值会报错

只有变量严格等于 undefined 是才会使用默认值，null 不会使用默认值

**箭头函数及其 this 问题**

关于箭头函数，内部的 this 指向定义是所在的上下文，而不是使用时所在的上下文，他不可以当做构造函数使用，不可以使用 new 命令，使用会报错，也没余原型对象，也没有参数对象 arguments，不过可以使用 rest 代替，也不可以使用 yield，箭头函数不能用作 generator

**Symbol 概念及其作用**

symbol 不能使用 new 命令，接受一个字符串作为参数，表示对 symbol 实例的描述，可在控制台显示转为字符串，symbol 作为属性名，不会被 forin，forof，Objet.key(),Object.getOwnPropertyNames()，遍历到，也不能被 JSON.stringfy 返回，但可以使用 Object.getOwnPropertySymbols 方法返回一个数组，成员是对象所有用作属性名的 Symbol 值

Symbol.for(),接受一个字符串做为参数，然后搜索有没有以该参数作为名称的 Symbol 的值，若有就返回这个 Symbol 值，没有就创建一个，相应的也有 Symbol.keyFor(),参数为一个变量，返回一个已登记的 symbol 类型的 key 值

**Set 和 Map 数据结构**

es6 提供的新的数据结构，set 和 map，同时还有 weakSet，weakMap

set 类似数组，但他里面存的都是唯一的值，没有重复值，weakSet 的成员只能是对象，不能是其他类型的值，weakSet 中的对象都是弱引用，即垃圾回收机制不考虑 weakSet 对该对象的引用

map 里存的都是键值对的集合，类似于对象，但是他的键不限于字符串也可以是其他类型的值，比如对象，weakMap 只接受对象组为健名，该对象也是弱引用，不计入垃圾回收机制

**Proxy**

proxy 是代理的意思，用于修改某些操作的默认行为，等同于在语言层面作出修改，所以属于一种元编程，也就是对编程语言尽行编程，proxy 就是在目标对象之前做一层拦截，外界访问该对象都必须经过这层拦截，因此它提供了一种机制，可以对外界的访问进行过滤和改写

**Reflect 对象**

Reflect 的目的是为了让一些明显属于语言内部的方法放到 Reflect 上，比如 Object.defineProperty,修改某些方法的返回结果，让其更合理,让 Object 的操作都变成函数行为

Reflect 与 Proxy 的方法一一对应，也就是说，不管 proxy 怎么修改默认行为，只要是 Proxy 对象的方法，就能在 Reflect 对象上找到对应的方法，总可以在 Reflect 上获取默认行为

**Promise（手撕 Promise A+规范、Promise.all、Promise 相关 API 和方法）**

略

**Iterator 和 for...of（Iterator 遍历器的实现）**

Iterator 是一种接口，为各种不同的数据类型提供统一的访问机制，任何数据类型只要部署 Iterator 接口，就可以完成便利操作，作用主要有三个，一是提供统一的简便的访问接口，二是使得数据结构的成员能够按照某种次序排序，三是 es6 提供了针对 Iterator 消费的 for of 遍历，js 有许多数据类型都默认部署了 Iterator 接口，比如 Array，map，set,String,arguments,nodelist

for of 可以再可迭代对象上创建一个迭代循环，调用自身的迭代钩子，为每个不同的属性的值执行语句

[for of](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of)

Iterator 遍历器的简单实现：

```js
const makeIterator = (array) => {
  var nextIndex = 0;
  return {
    next: function() {
      return nextIndex < array.length
        ? { value: array[nextIndex++], done: false }
        : { value: undefined, done: true };
    },
  };
};
```

**循环语法比较及使用场景（for、forEach、for...in、for...of）**

1. for 循环
   缺点是很麻烦。

2. forEach
   回调函数参数分别是 value,index,array

   缺点在于无法中途跳出 forEach 循环，break 和 return 命令都不行。

3. for…in
   用于遍历所有的可枚举属性，功能类似于 Object.keys()，但是遍历不到 constructor、length 这样的不可枚举属性。

   缺点：

   数组的键名为数字，但是 for…in 循环是以字符串作为键名"0",“1”,“2”

   for…in 循环主要是为遍历对象而设计的，不适用于遍历数组。

4. for…of
   for…of 是 ES6 新增的遍历方式，它提供了统一的遍历机制。所有实现了`[Symbol.iterator]`接口的对象都可以被遍历。for…of 循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、DOM NodeList 对象）、Generator 对象，以及字符串

   优点：1、用法简洁 2、可以和 break,continue,return 配合使用 3、提供了遍历所有数据结构的统一操作接口。

   三个遍历器对象：

- entries() 返回一个遍历器对象，一个给定对象自身可枚举属性的键值对数组,其排列与使用 for...in 循环遍历该对象时返回的顺序一致（区别在于 for-in 循环还会枚举原型链中的属性）,对于数组，键名就是索引值；对于 Set，键名与键值相同。Map 结构的 Iterator 接口，默认就是调用 entries 方法。
- keys() 返回一个遍历器对象，一个由一个给定对象的自身可枚举属性组成的数组。
- values() 返回一个遍历器对象，一个给定对象自身的所有可枚举属性值的数组。

**Generator 及其异步方面的应用**

Generator 是一种异步编程解决方案，最大的特点就是可以交出函数的执行权，和 yield 配合返回的是一个迭代器

Generator 是 es6 的一个新关键词，是一个带星号的函数，但他不是一个函数，可以配合 yield 关键字来暂停或执行函数执行，当声明了一个 Generator 变量后，程序会阻塞住，不会执行任何语句，这个变量是 object 而不是 function，调用 gen.next()，程序会继续执行到 yield 关键词处停止，next 方法会返回一个对象，对象有两个属性，value 和 done，value 表示 yield 返回的值，done 表示 Generator 是否执行完毕

Generator 在异步方面的应用，可以通过 Generator 与 thunk 函数结合来实现异步的控制，thunk 函数的基本思路是接受一定的参数，会产出定制化的函数，最后使用定制化的函数去实现想要实现的功能比如一个读取文件的例子

```js
const readFileThunk = (filename) => {
  return (callback) => {
    fs.readFile(filename, callback);
  };
};

const gen = function*() {
  const data1 = yield readFileThunk("./1.txt");
  console.log(data1.toString());
  const data2 = yield readFileThunk("./2.txt");
  console.log(data2.toString());
};

let g = gen();
g.next().value((err, data1) => {
  g.next(data1).value((err, data2) => {
    g.next(data2);
  });
});

//将执行的代码进行封装

function run(gen) {
  const next = (err, data) => {
    let res = gen.next(data);
    if (res.done) return;
    res.value(next);
  };
  next();
}
```

Generator 也可以与 Promise 结合

```js
const readFilePromise = function(filename) {
  return new Promise((resolve, reject) => {
    fs.readFile(filename, (err, data) => {
      if (err) {
        reject(err);
      } else {
        resolve(data);
      }
    });
  }).then((res) => res);
};

const gen = function*() {
  const data1 = yield readFilePromise("./1.txt");
  console.log(data1.toString());
  const data2 = yield readFilePromise("./2.txt");
  console.log(data2.toString());
};

function run(gen) {
  const next = (err, data) => {
    let res = gen.next(data);
    if (res.done) return;
    res.value.then(next);
  };
  next();
}
run(g);
```

有一个 co 函数库可以处理 Generator 的自动执行，核心就是通过 thunk 函数以及 Promise 对象进行配合来实现

Generator 就是一个异步操作的容器，它需要一种自动执行机制，co 函数库接受一个 Generator 函数作为参数然后返回一个 Promise，在返回的 Promise 函数里检查 gen 是否为 Generator 函数，如果是，就执行该函数，否则将 Promise 对象的状态改为 resolved，co 将 Generator 函数的内部指针对象的 next 方法包装成 onFulfilled 函数，这样做的是为了能够捕获抛出的错误，关键是配合 next 函数，反复调用自身

**async 函数**

async/await 可以让我们用同步的方式来书写异步的代码，又得到底层语法的支持，无需借助任何第三方库，async 相对于 Generator 的改进体现在内置执行器，适应性更好，可读性更好，它其实是 Generator 与 Promise 的语法糖

一个带有 async 的函数返回的必定是一个 Promise 对象，如果函数没有返回一个 Promise，他会自动用 Promise.resolve()包装，如果显式的返回了 Promise，那就以返回的 Promise 为准

await 右侧如果是函数，那么返回函数的返回值就是表达式结果，右侧如果是'123'，或者什么值，拿表达式的结果就是 123

async/awiat 还可以使用 try/catch 来同时处理同步和异步的错误

**几种异步方式的比较（回调、setTimeout、Promise、Generator、async）**

[异步](http://vhblog.ygjie.icu/zh/essay/25/#%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5)

**class 基本语法及继承**

class 的出现是为了不出 js 缺少一些面向对象语言的特性，但本质上来说是一种构造函数的语法糖，背后依然是原型继承的思想，采用的是寄生组合式继承，通过 class 可以更好地组织代码，在 class 上添加方法其实是在类的原型上添加方法,class 内部默认采用的是严格模式，class 中的静态方法不可以被继承，可以通过类名来调用，也可以在子类中通过 super 来调用，类中的 construct 默认返回实例对象，但也可以返回另一个对象，类必须使用 new 来调用，类不存在变量提升因为有继承，所以必须保证子类在父类后面，私有方法 es6 不提供，只能通过变通的方法来模拟私有变量，比如 symbol，类的内部 this 默认指向类的实例

类的继承可以通过 extend 来实现这比通过修改原型链继承更加清晰方便，子类必须在 construct 中调用 super 否则得不到 this 对象，super 要放到使用 this 前面，否则创建实例时会报错

**模块加载方案比较（CommonJS 和 ES6 的 Module）**

- es6 模块输出的是值的引用，commonjs 输出的是值的拷贝
  - 值的拷贝意味着一旦输出一个值，模块内部的变化就影响不到这个值，es6 模块的运行机制和 common 不一样，js 在对脚本静态分析的时候，遇到模块加载命令 import，会生成一个只读的引用，等到脚本真正执行的时候再根据这个只读的引用，到被加载的那个模块里去取值
- commonjs 是运行时加载，es6 模块是编译时加载输出接口
  - 运行时加载就是先加载整个模块，生成一个对象，然后从这个对象上读取方法
  - 编译时加载：e6 模块 s 不是对象，而是通过 export 命令显示指定输出代码，import 时采用静态命令的形式，在 import 时指定加载某个输出值，而不是加载整个模块，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成
- commonjs 模块加载方式并不是语言层面的标准，只能在运行时确定模块的依赖关系以及输入输出变量，而 es6 模块在语言规格层面支持模块功能，支持编译时静态分析，便于 js 引入宏和类型检查，动态绑定
- commonjs 导入模块是只能是的路劲可以是一个表达式，因为使用的 require()方法，而 es6 模块只能是字符串
- commonjs 模块的 this 指向当前模块，而 es6 模块的 this 指向 undefined

**ES6 模块加载与 CommonJS 加载的原理**

略

## HTML/CSS

**CSS 权重及其引入方式**

判断优先级时，首先我们会判断一条属性声明是否有权重，也就是是否在声明后面加上了!important。一条声明如果加上了权重，那么它的优先级就是最高的，前提是它之后不再出现相同权重的声明。如果权重相同，我们则需要去比较匹配规则的特殊性。

一条匹配规则一般由多个选择器组成，一条规则的特殊性由组成它的选择器的特殊性累加而成。选择器的特殊性可以分为四个等级，第一个等级是行内样式，为 1000，第二个等级是 id 选择器，为 0100，第三个等级是类选择器、伪类选择器和属性选择器，为 0010，第四个等级是元素选择器和伪元素选择器，为 0001。规则中每出现一个选择器，就将它的特殊性进行叠加，这个叠加只限于对应的等级的叠加，不会产生进位。选择器特殊性值的比较是从左向右排序的，也就是说以 1 开头的特殊性值比所有以 0 开头的特殊性值要大。比如说特殊性值为 1000 的的规则优先级就要比特殊性值为 0999 的规则高。如果两个规则的特殊性值相等的时候，那么就会根据它们引入的顺序，后出现的规则的优先级最高

**`<a></a>`标签全部作用**

a 标签有四个作用：

1. 使用 target 规定在何处打开文档，也就是超连接作用
2. 设置锚点
3. 打电话或发邮件
4. 协议限定符

target 属性有：`_blank`,`_self`,`_parent`,`_top`

锚点通过`#`配合 id 来设置

打电话发邮件时需要将`href`设置为`tel:xxx`,`mailto:xxx`

最后一种协议限定符这样使用:`<a href="javascript:alert('alert')">点击a标签时执行里面的代码</a>`

**用 CSS 画三角形**

```css
.demo {
  weight: 0;
  height: 0;
  border-top: 40px solid transparent;
  border-bottom: 40px solid transparent;
  border-left: 40px solid transparent;
  border-right: 40px solid red;
}
```

**未知宽高元素水平垂直居中（方案及比较）**

[](http://vhblog.ygjie.icu/zh/essay/24/#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80)

**元素种类的划分**

块状元素、内联元素(又叫行内元素)和内联块状元素

块级元素总是独占一行，另起一行开始，后面的元素也得另起一行，宽度，高度，内边距，外边距都可以控制

内联元素和相邻的内联元素在同一行，只要 padding 和 margin 的 left 和 right 可以设置，其他宽度高度等等都不可设置

inline-block 可以这这是宽高，不会自动换行，一般有，input，button，img，label，texterea

**盒子模型及其理解**

css 盒模型描述了以文档树中的元素而生成的矩阵框，并根据排版模式进行布局，每个盒子都有一个内容区域以及周围可选的 padding，border，margin,css 盒模型负责计算块级元素占用多少空间，边框是否重叠，边距是否合并，盒子的尺寸

盒模型有以下规则：

- 块级元素大小由 width，height，padding，margin,border 共同决定
- 如果没有指定 height，块级元素的高度等于其包含的子元素的告诉加上 padding(在没有浮动的情况下)
- 如果没有指定 width，非浮动元素的宽度等于其父元素的宽度减去父元素的 padding
- 元素的 height 是由内容的 height 来计算的。
- 元素的 width 是由内容的 width 来计算的。
- 默认情况下，padding 和 border 不是元素 width 和 height 的组成部分

盒模型又分为标准盒模型和 ie 盒模型

盒模型都是由四个部分组成的，分别是 margin、border、padding 和 content。

标准盒模型和 IE 盒模型的区别在于设置 width 和 height 时，所对应的范围不同。标准盒模型的 width 和 height 属性的范围只包含了 content，而 IE 盒模型的 width 和 height 属性的范围包含了 border、padding 和 content。

一般来说，我们可以通过修改元素的 box-sizing 属性来改变元素的盒模型

::: tip
在 ie8+浏览器中使用哪个盒模型可以由 box-sizing（CSS 新增的属性）控制，默认值为 content-box，即标准盒模型；

如果将 box-sizing 设为 border-box 则用的是 IE 盒模型。如果在 ie6，7，8 中 DOCTYPE 缺失会将盒子模型解释为 IE 盒子模型。若在页面中声明了 DOCTYPE 类型，所有的浏览器都会把盒模型解释为 W3C 盒模型
:::

**定位方式及其区别（文档流）**

absolute 生成绝对定位的元素，相对于值不为 static 的第一个父元素的 paddingbox 进行定位，也可以理解为离自己这一级元素最近的一级 position 设置为 absolute 或者 relative 的父元素的 paddingbox 的左上角为原点的。不为元素预留空间，绝对定位的元素可以设置外边距（margins），且不会与其他边距合并

fixed 不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先

relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白）

static 默认值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index 属性无效

sticky 是 2017 年浏览器才开始支持，会产生动态效果，类似 relative 和 fixed 的结合，一个实例是"动态固定"，生效前提是必须搭配 top,left,bottom,right 一起使用，不能省略，否则等同于 relative 定位，不产生"动态固定"的效果

::: tip 谈到 float 还有 position 中的 absolute 和 fixed 脱离文本流的时候，问到底是脱离文档流还是文本流

文档流是相对于盒子模型讲的

文本流是相对于文子段落讲的

元素浮动之后，会让它跳出文档流，也就是说当它后面还有元素时，其他元素会无视它所占据了的区域，直接在它身下布局。但是文字却会认同浮动元素所占据的区域，围绕它布局，也就是没有拖出文本流。

但是绝对定位后，不仅元素盒子会拖出文档流，文字也会出文本流。那么后面元素的文本就不会在认同它的区域位置，会直接在它后面布局，不会在环绕。当然你可以使用 index-z 来让底部的元素到上面来，类似于一个图层的概念
:::

**margin 塌陷及合并问题**

margin 重叠指的是在垂直方向上，两个相邻元素的 margin 发生重叠的情况。

一般来说可以分为四种情形：

第一种是相邻兄弟元素的 marin-bottom 和 margin-top 的值发生重叠。这种情况下我们可以通过设置其中一个元素为 BFC 来解决。

第二种是父元素的 margin-top 和子元素的 margin-top 发生重叠。它们发生重叠是因为它们是相邻的，所以我们可以通过这一点来解决这个问题。我们可以为父元素设置 border-top、padding-top 值来分隔它们，当然我们也可以将父元素设置为 BFC 来解决。

第三种是高度为 auto 的父元素的 margin-bottom 和子元素的 margin-bottom 发生重叠。它们发生重叠一个是因为它们相邻，一个是因为父元素的高度不固定。因此我们可以为父元素设置 border-bottom、padding-bottom 来分隔它们，也可以为父元素设置一个高度，max-height 和 min-height 也能解决这个问题。当然将父元素设置为 BFC 是最简单的方法。

第四种情况，是没有内容的元素，自身的 margin-top 和 margin-bottom 发生的重叠。我们可以通过为其设置 border、padding 或者高度来解决这个问题。

**浮动模型及清除浮动的方法**

浮动（float）是 CSS 定位属性。浮动元素从网页的正常流动中移出，但是保持了部分的流动性，会影响其他元素的定位（比如文字会围绕着浮动元素）。这一点与绝对定位不同，绝对定位的元素完全从文档流中脱离。

CSS 的 clear 属性通过使用 left、right、both，让该元素向下移动（清除浮动）到浮动元素下面

如果父元素只包含浮动元素，那么该父元素的高度将塌缩为 0。我们可以通过清除（clear）从浮动元素后到父元素关闭前之间的浮动来修复这个问题

清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示

清除浮动的方法有：

- 额外标签，即在最后一个浮动标签后加一个空 div，给其设置 clear:both ，缺点是增加无意义标签，语义化差
  - a 内部标签：会将父盒子的高度重新撑开
  - b 外部标签：只能将浮动盒子的影响清除，但是不会撑开盒子
- 给父级元素添加 overflow:不为 visible 通过触发 BFC 的方式清除浮动，先找到浮动盒子的父元素，给父元素添加一个属性：overflow:hidden;就会清除子元素对页面的影响（不推荐使用）
- 使用 after 伪元素，缺点是 IE6-7 不支持伪元素，zoom:1 触发 hasLayout,zoom 属性是 IE 浏览器的专有属性

::: tip clear 属性清除浮动的原理
如果单看字面意思，clear:left 应该是“清除左浮动”，clear:right 应该是“清除右浮动”的意思，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。

官方对 clear 属性的解释是：“元素盒子的边不能和前面的浮动元素相邻。”，我们对元素设置 clear 属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动还需要注意的一点是 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“前面的”3 个字，也就是 clear 属性对“后面的”浮动元素是不闻不问的。考虑到 float 属性要么是 left，要么是 right，不可能同时存在，同时由于 clear 属性对“后面的”浮动元素不闻不问，因此，当 clear:left 有效的时候，clear:right 必定无效，也就是此时 clear:left 等同于设置 clear:both；同样地，clear:right 如果有效也是等同于设置 clear:both。由此可见，clear:left 和 clear:right 这两个声明就没有任何使用的价值，至少在 CSS 世界中是如此，直接使用 clear:both 吧。

clear 属性只有块级元素才有效的，而::after 等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置 display 属性值的原因
:::

**display 及相关属性**

这个属性用于定义建立布局时元素生成的显示框类型

block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。

none 元素不显示，并从文档流中移除。

inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。

inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。

list-item 像块类型元素一样显示，并添加样式列表标记。

table 此元素会作为块级表格来显示。

inherit 规定应该从父元素继承 display 属性的值

::: tip display 、position 和 float 的相互关系
（1）首先我们判断 display 属性是否为 none，如果为 none，则 position 和 float 属性的值不影响元素最后的表现。

（2）然后判断 position 的值是否为 absolute 或者 fixed，如果是，则 float 属性失效，并且 display 的值应该被设置为 table 或者 block，具体转换需要看初始转换值。

（3）如果 position 的值不为 absolute 或者 fixed，则判断 float 属性的值是否为 none，如果不是，则 display 的值则按上面的规则转换。注意，如果 position 的值为 relative 并且 float 属性的值存在，则 relative 相对于浮动后的最终位置定位。

（4）如果 float 的值为 none，则判断元素是否为根元素，如果是根元素则 display 属性按照上面的规则转换，如果不是，则保持指定的 display 属性值不变。

总的来说，可以把它看作是一个类似优先级的机制，"position:absolute"和"position:fixed"优先级最高，有它存在的时候，浮动不起作用，'display'的值也需要调整；其次，元素的'float'特性的值不是"none"的时候或者它是根元素的时候，调整'display'的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，'display'特性值同设置值。
:::

::: tip 使用 display:inline-block 会产生什么问题

**产生空白的原因**

元素被当成行内元素排版的时候，元素之间的空白符（空格、回车换行等）都会被浏览器处理，根据 CSS 中 white-space 属性的处理方式（默认是 normal，合并多余空白），原来 HTML 代码中的回车换行被转成一个空白符，在字体不为 0 的情况下，空白符占据一定宽度，所以 inline-block 的元素之间就出现了空隙

**解决办法:**

1. 将子元素标签的结束符和下一个标签的开始符写在同一行或把所有子标签写在同一行
2. 父元素中设置 font-size: 0，在子元素上重置正确的 font-size
3. 为子元素设置 float:left
   :::

**IFC 与 BFC**

**BFC （Block formatting contexts ）：**

块级格式上下文页面上的一个隔离的渲染区域，那么他是如何产生的呢？可以触发 BFC 的元素有 float、position、overflow、display：table-cell/inline-block/table-caption ；BFC 有什么作用呢？比如说实现多栏布局’

**IFC （Inline formatting contexts ）：**

内联格式上下文 IFC 的 line box（线框）高度由其包含行内元素中最高的实际高度计算而来（不受到竖直方向的 padding/margin 影响)IFC 中的 line box 一般左右都贴紧整个 IFC，但是会因为 float 元素而扰乱。float 元素会位于 IFC 与与 line box 之间，使得 line box 宽度缩短。 同个 ifc 下的多个 line box 高度会不同 IFC 中时不可能有块级元素的，当插入块级元素时（如 p 中插入 div）会产生两个匿名块与 div 分隔开，即产生两个 IFC，每个 IFC 对外表现为块级元素，与 div 垂直排列。那么 IFC 一般有什么用呢？水平居中：当一个块要在环境中水平居中时，设置其为 inline-block 则会在外层产生 IFC，通过 text-align 则可以使其水平居中。垂直居中：创建一个 IFC，用其中一个元素撑开父元素的高度，然后设置其 vertical-align:middle，其他行内元素则可以在此父元素下垂直居中。

**GFC （GrideLayout formatting contexts ）：**

网格布局格式化上下文当为一个元素设置 display 值为 grid 的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。那么 GFC 有什么用呢，和 table 又有什么区别呢？首先同样是一个二维的表格，但 GridLayout 会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。

**FFC （Flex formatting contexts ）:**

自适应格式上下文 display 值为 flex 或者 inline-flex 的元素将会生成自适应容器（flex container），可惜这个牛逼的属性只有谷歌和火狐支持，不过在移动端也足够了，至少 safari 和 chrome 还是 OK 的，毕竟这俩在移动端才是王道。FlexBox 由伸缩容器和伸缩项目组成。通过设置元素的 display 属性为 flex 或 inline-flex 可以得到一个伸缩容器。设置为 flex 的容器被渲染为一个块级元素，而设置为 inline-flex 的容器则渲染为一个行内元素。伸缩容器中的每一个子元素都是一个伸缩项目。伸缩项目可以是任意数量的。伸缩容器外和伸缩项目内的一切元素都不受影响。简单地说，Flexbox 定义了伸缩容器内伸缩项目该如何布局。

**圣杯布局和双飞翼布局的实现**

[](http://vhblog.ygjie.icu/zh/essay/24/#%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80)

**Flex 布局**

flex 布局是 CSS3 新增的一种布局方式，我们可以通过将一个元素的 display 属性值设置为 flex 从而使它成为一个 flex 容器，它的所有子元素都会成为它的项目。

一个容器默认有两条轴，一个是水平的主轴，一个是与主轴垂直的交叉轴。我们可以使用 flex-direction 来指定主轴的方向。

我们可以使用 justify-content 来指定元素在主轴上的排列方式，使用 align-items 来指定元素在交叉轴上的排列方式。还可以使用 flex-wrap 来规定当一行排列不下时的换行方式。

对于容器中的项目，我们可以使用 order 属性来指定项目的排列顺序，还可以使用 flex-grow 来指定当排列空间有剩余的时候，项目的放大比例。还可以使用 flex-shrink 来指定当排列空间不足时，项目的缩小比例

::: tip flex 属性
以下 6 个属性设置在容器上。

flex-direction 属性决定主轴的方向（即项目的排列方向）。

flex-wrap 属性定义，如果一条轴线排不下，如何换行。

flex-flow 属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 rownowrap。

justify-content 属性定义了项目在主轴上的对齐方式。

align-items 属性定义项目在交叉轴上如何对齐。

align-content 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。

以下 6 个属性设置在项目上。

order 属性定义项目的排列顺序。数值越小，排列越靠前，默认为 0。

flex-grow 属性定义项目的放大比例，默认为 0，即如果存在剩余空间，也不放大。

flex-shrink 属性定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。

flex-basis 属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为 auto，即项目的本来大小。

flex 属性是 flex-grow，flex-shrink 和 flex-basis 的简写，默认值为 01auto。

align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。
:::

**px、em、rem 的区别**

px 像素（Pixel）。相对长度单位。像素 px 是相对于显示器屏幕分辨率而言的

1. IE 无法调整那些使用 px 作为单位的字体大小；
2. 国外的大部分网站能够调整的原因在于其使用了 em 或 rem 作为字体单位；
3. Firefox 能够调整 px 和 em，rem，但是 96%以上的中国网民使用 IE 浏览器(或内核)。

em 是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸

1. em 的值并不是固定的；
2. em 会继承父级元素的字体大小。

::: tip
任意浏览器的默认字体高都是 16px。所有未经调整的浏览器都符合: 1em=16px。那么 12px=0.75em,10px=0.625em。为了简化 font-size 的换算，需要在 css 中的 body 选择器中声明 Font-size=62.5%，这就使 em 值变为 16px\*62.5%=10px, 这样 12px=1.2em, 10px=1em, 也就是说只需要将你的原来的 px 数值除以 10，然后换上 em 作为单位就行了
:::

rem 是 CSS3 新增的一个相对单位（root em，根 em），这个单位与 em 有什么区别呢？区别在于使用 rem 为元素设定字体大小时，仍然是相对大小，但相对的只是 HTML 根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应，目前，除了 IE8 及更早版本外，所有浏览器均已支持 rem

优点：

在屏幕分辨率千差万别的时代，只要将 rem 与屏幕分辨率关联起来就可以实现页面的整体缩放，使得在设备上的展现都统一起来了。而且现在浏览器基本都已经支持 rem 了，兼容性也非常的好。

缺点：

1. 在奇葩的 dpr 设备上表现效果不太好，比如一些华为的高端机型用 rem 布局会出现错乱。

2. 使用 iframe 引用也会出现问题。

3. rem 在多屏幕尺寸适配上与当前两大平台的设计哲学不一致。即大屏的出现到底是为了看得又大又清楚，还是为了看的更多的问题。

::: tip
对于只需要适配少部分手机设备，且分辨率对页面影响不大的，使用 px 即可。

对于需要适配各种移动设备，使用 rem，例如只需要适配 iPhone 和 iPad 等分辨率差别比较挺大的设备
:::

**Less 预处理语言**

略

**媒体查询**

假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来，而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS 就是为文档提供在不同媒介上展示的适配方法当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。当媒体查询返回假，标签上带有媒体查询的样式表仍将被下载（只不过不会被应用）。包含了**一个媒体类型**和**至少一个使用宽度、高度和颜色等媒体属性**来限制样式表范围的表达式。CSS3 加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围

**vh 与 vw**

- vw : 1vw 等于视口宽度的 1%
- vh : 1vh 等于视口高度的 1%
- vmin : 选取 vw 和 vh 中最小的那个
- vmax : 选取 vw 和 vh 中最大的那个

**H5 的语义化作用及语义化标签**

html 语义化主要指的是我们应该使用合适的标签来划分网页内容的结构。html 的本质作用其实就是定义网页文档的结构，一个语义化的文档，能够使页面的结构更加清晰，易于理解。这样不仅有利于开发者的维护和理解，同时也能够使机器对文档内容进行正确的解读

比如说我们常用的 b 标签和 strong 标签，它们在样式上都是文字的加粗，但是 strong 标签拥有强调的语义。对于一般显示来说，可能我们看上去没有差异，但是对于机器来说，就会有很大的不同。如果用户使用的是屏幕阅读器来访问网页的话，使用 strong 标签就会有明显的语调上的变化，而 b 标签则没有。如果是搜索引擎的爬虫对我们网页进行分析的话，那么它会依赖于 html 标签来确定上下文和各个关键字的权重，一个语义化的文档对爬虫来说是友好的，是有利于爬虫对文档内容解读的，从而有利于我们网站的 SEO

从 html5 我们可以看出，标准是倾向于以语义化的方式来构建网页的，比如新增了 header 、footer 这些语义标签，删除了 big 、font 这些没有语义的标签

**Web Worker 和 Web Socket**

web worker 就是在 web 应用程序中使用的 worker。这个 worker 是独立于 web 主线程的，在后台运行的线程,web worker 的优点就是可以将工作交给独立的其他线程去做，这样就不会阻塞主线程

基本使用：

1. 通过 `worker = new Worker( url )` 加载一个 JS 文件来创建一个 worker，同时返回一个 worker 实例。

2. 通过`worker.postMessage( data )` 方法来向 worker 发送数据。

3. 绑定`worker.onmessage`方法来接收 worker 发送过来的数据。

4. 可以使用 `worker.terminate()` 来终止一个 worker 的执行。

WebSocket 是 Web 应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个 Html5 协议，WebSocket 的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询

**CSS3 及相关动画**

略

**如何实现响应式布局**

响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。页面头部必须有 meta 声明的 viewport

::: tip 响应式设计与自适应设计有何不同
响应式设计和自适应设计都以提高不同设备间的用户体验为目标，根据视窗大小、分辨率、使用环境和控制方式等参数进行优化调整。

响应式设计的适应性原则：网站应该凭借一份代码，在各种设备上都有良好的显示和使用效果。响应式网站通过使用媒体查询，自适应栅格和响应式图片，基于多种因素进行变化，创造出优良的用户体验。就像一个球通过膨胀和收缩，来适应不同大小的篮圈。

自适应设计更像是渐进式增强的现代解释。与响应式设计单一地去适配不同，自适应设计通过检测设备和其他特征，从早已定义好的一系列视窗大小和其他特性中，选出最恰当的功能和布局。与使用一个球去穿过各种的篮筐不同，自适应设计允许使用多个球，然后根据不同的篮筐大小，去选择最合适的一个
:::

**SEO 的概念及实现**

前端需要注意哪些 SEO

（1）合理的 title、description、keywords：搜索对着三项的权重逐个减小，title 值强调重点即可，重要关键词出现不要超过 2 次，而且要靠前，不同页面 title 要有所不同；description 把页面内容高度概括，长度合适，不可过分堆砌关键词，不同页面 description 有所不同；keywords 列举出重要关键词即可。

（2）语义化的 HTML 代码，符合 W3C 规范：语义化代码让搜索引擎容易理解网页。

（3）重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取长度有限制，保证重要内容肯定被抓取。

（4）重要内容不要用 js 输出：爬虫不会执行 js 获取内容

（5）少用 iframe：搜索引擎不会抓取 iframe 中的内容

（6）非装饰性图片必须加 alt

（7）提高网站速度：网站速度是搜索引擎排序的一个重要指标

在 SEO 中，所谓的 TDK 其实就是 title、description、keywords 这三个标签，title 标题标签，description 描述标签，keywords 关键词标签

**HTML5 的新特性**

HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。

新增的有：

+ 绘画 canvas;
+ 用于媒介回放的 video 和 audio 元素;
+ 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
+ sessionStorage 的数据在浏览器关闭后自动删除;
+ 语意化更好的内容元素，比如 article、footer、header、nav、section;
+ 表单控件，calendar、date、time、email、url、search;
+ 新的技术 webworker, websocket;
+ 新的文档属性 document.visibilityState

移除的元素有：

+ 纯表现的元素：basefont，big，center，font, s，strike，tt，u;
+ 对可用性产生负面影响的元素：frame，frameset，noframes；

**Less 和 Sass 使用**

略


