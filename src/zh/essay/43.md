---
time: 2021-03-16
icon: template
category: 面试
article: true
sidebar: auto
footer: 😁😁😁
tag:
  - 前端
---

# 牛客上一篇前端知识汇总

> [原文链接](https://www.nowcoder.com/discuss/258810)
> 这篇文章等于说是在做题

## JavaScript

**原始值和引用值类型及区别**

在 JavaScript 中数据类型分两种，一类是基本类型的值，另一类是复杂数据类型，基本数据类型包括 7 种：undefined，null，boolean，string,number,bigInt,Symbol,复杂数据类型在 JavaScript 中主要是对象类型，在这之中又包含许多子类型，比如普通对象，数组，函数，Math，正则等等

然后就是存储方式，基本类型一般存的原始值，复杂数据类型一般是引用值，具体的含义就是，原始值的话，当你引用它是值拷贝的方式，一般存储在栈中，引用类型的值引用它时只是引用了一个指向它的内存地址的指针，这个指针存在栈中，这就会导致一个共享内存的问题，当把一个复杂数据类型赋值给另一个变量，由于是将其指针进行了拷贝，所以当修改其中一个对象的，所有值为这个指针的对象都会发生相应的改变

::: tip
关于数据类型这一块，还可以讲讲关于数据类型的判断，类型转换
:::

**判断数据类型 typeof、instanceof、Object.prototype.toString.call()、constructor**

typeof 适合用来判断基本数据类型，对于基本类型一般会返回对应的数据类型的字符换，而对于复杂数类型除 function 外一般会返回 Object，用 typeof 判断 function 会返回字符串 function，基本数据类型中 null 是个例外，typeof 判断 null 会返回 object，这是因为 JavaScript 中不同的对象在底层都表示为二进制，当二进制前三位全为 0 时会被判断为 object，null 的二进制表示全 0，自然前三位也是 0，typeof 就会将其判断位 Object，但这不影响 null 是基本数据类型，这只是语言本身的 bug

instanceof 用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上，所以这这个操作符的本质就是基于原型链查找，会沿着 left 得原型链查找，若找到了 right 就返回 true，所以 instance 实现的话大致就是在一个循环中不断获取 left 得原型，并检查是否与 right 相等，left 为对象，right 为函数，我们还可以在一个类上自定义 instanceof ，Symbol.hasInstance 用于判断某对象是否为构造器的实例,所以这样就可以在内部使用 typeof 来判断基本数据类型了

```js
class Array1 {
  static [Symbol.hasInstance](instance) {
    return typeof instance === "number";
  }
}
console.log(111 instanceof Array1);
```

Object.toString.call(),是调用了 Object 上的 toString 方法，之所以任何数据类型都可以调用该方法是因为，JavaScript 中基本数据类型会先转为包装对象，然后所有对象最终的原型指向都是 Object，所以可以调用 toString 方法，调用该方法后会返回一个[object 数据类型]的字符串，这个方法对基本数据类型和复杂数据类型都有效，这种方法的一个缺点是对于自定义对象总是返回[object Object],所以该方法常用来判断内置对象

constructor 也可以用来判断数据类型，constructor 属性返回创建此对象的数组函数的引用，不能对 null 和 undefined 使用

**类数组与数组的区别与转换**

类数组是指写法上跟数组一样，但不是数组，她的原型是 Object，而数组的原型是 Array

类数组一般有 arguments , HTMLCollection, NodeList

关于 arguments 对象，他是函数的参数对象，通过 Object.prototype.toString.call()返回的结果是[object arguments],这个对象里面有一个 calle 属性可以返回函数本身，该属性从 es5 严格模式删除了

HTMLCollection 是 html dom 对象的一个接口，这个接口包含了获取到的 DOM 元素集合，返回的类型也是类数组对象，随文档中的 dom 变化而变化

NodeList 对象是节点的集合，通常由 querySelect 返回也是一种类数组，虽然不是一个数组但可以用 for of 迭代，也是一个实时集合

关于转换类数组，因为类数组并没有自带一些数组的方法，一般可以使用 call 来借用 Array 原型链上的方法来操作，比如 slice，concat，也可以使用扩展运算符来装换

**数组的常见 API**

数组常见的 API 大致可以分为三种一种是改变数组自身的方法，然后是不改变数组自身即返回一个新数组的方法，还有就是遍历的方法

改变数组自身的方法有：push,pop,shift,unshift,reverse,splice,fill,copyWithin

不改变数组自身的方法有：slice,concat,join,toString,toLocalString(根据本地时间把 Date 对象转换为字符串),indexof,lastIndexof,includes

遍历方法有：forEach,map,some,eveny,filter,reduce,find,findIndex 还有对象原型上的一些方法 keys,values,entries

::: tip
这一块还有一些 API 的实现：map，splice,pop,push,reduce,filter
:::

**bind、call、apply 的区别**

这三个方法都是在 Function 的原型上的，都用来显示的绑定 this，call 和 reply 可以由函数调用，然后第一个参数传入要绑定的上下文，后面的参数为要传给函数参数，apply 是将后续的这些参数写入到一个数组然后作为第二个参数，call 是将这些参数一个一个的作为 call 的后续参数，所以他们两个的区别就是对传入给函数的参数的传入形式不一样，最终的效果是一样的，而 bind 并不是想刚才哪两个一样直接执行函数，他先进行显示绑定 this，然后返回一个函数，然后可以自由的去调用这个函数，传入给函数参数的形式和 call 一样

**new 的原理**

当我们执行了一个 new 操作，它内部会执行四个步骤，一是先创建一个空对象，第二是将构造函数的作用域赋值给新对象，也就是将 this 指向新对象，通过 Object 的原型上的 create 方法，第三个是执行构造函数，第四个是返回这个对象，其中若构造函数又返回一个对象那么就返回这个对象，否则返回前面创建的那个对象

**如何正确判断 this？**

关于 this 有显示绑定和隐式绑定，显示得很好判断，因为自己使用 call,apply,bind 来绑定，隐式的话若不考虑箭头函数那么 this 指向哪是由他在哪运行决定的，也就是 this 指向当前调用它的上下文，如果找不到就指向全局，而箭头函数和他很不一样的一点就是它内部 this 的执行是由他在哪里定义决定的，而不有运行时决定，也可以说她的 this 指向当前离他最近的非箭头函数的 this

举个例子，比如说，在函数里面有一个函数函数内获取 this，如果通过这个对象直接调用这个函数那么这是 this 指向这个对象，而如果把这个对象单独赋值给一个全局变量，这时 this 就指向全局，浏览器里是 window，nodejs 环境下为 global，严格模式选为 undefined

上面说了两种关于运行时决定 this 的指向，还有就是比如全局定义一个函数的，这是函数的 this 指向全局，通过构造函数 new 了一个实例，此时构造函数的 this 指向这个实例，还有比如浏览器中的监听事件 onclick，addEventListen，默认指向绑定的元素，IE 的话比较奇怪，使用 attachEvent 里面的 this 指向 undefined

还有一些比较特殊的情况，就是数组的遍历 API，第一个参数通常为回调函数，第二个参数可以显示绑定 this；还有就是函数中的 this 是不会传递的，比如函数里嵌套函数，外层函数的 this 有运行时所在的上下文决定，这个上下文不会传递给嵌套的函数，最后就是类中的 this 指向，类中的 this 指向类本身，但还是 this 有运行时的上下文决定，若将类中的方法赋值给全局变量，然后在全局进行调用，由于 class 内部默认采用严格模式，所以 this 并不会指向全局而是指向 undefined

**闭包及其作用**

闭包是基于作用域链的，是当前作用域可以访问到父级作用域，针对的是函数，一个嵌套另一个函数，当里面的函数引用了外层函数的变量就形成了当前作用域访问到了父级作用域，此时就形成了闭包，这是嵌套的函数同时保存了当前作用域和父级作用域

产生闭包一般有函数内返回返回另一个函数，函数作为参数进行传递，立即执行函数，比如 js 中经常会在 setTimeout，事件监听中中使用回调函数，这也是闭包，还有 webpack 打包后的结果是一个立即执行函数，这也是闭包

闭包的优点就是可以访问并保存父级作用域，这样就可以形成私有变量，同时由于保存了父级作用域，自然父级作用域就不会被垃圾回收，这样也会产生一个缺点就是，当这种操作很多的话，由于许多父级作用域被引用，并不会被垃圾回收，就会导致内存泄漏

闭包的另一个优点是他可以用来实现模块化，从而避免全局变量的一个污染，因为立即执行函数就为模块提供了私有空间，具体做法就是将每个模块成员都放到一个立即执行函数所形成的私有作用域中，而对于需要暴露给外部的成员，可以挂载到全局对象上，因为立即执行函数保存当前父级也就是全局作用域

还有一种模块的方式就是函数返回一个有许多函数组成的对象，这个模块其实是暴露给了全局

闭包的用途除了刚刚说的私有作用域模块化之外还有，可以实现单例模式，还有比较经典的循环里打印下标

**原型和原型链**

JavaScript 是一门基于原型的语言，原型可以分为隐式原型和显式原型，比如我声明一个空对象，这是通过 Object.getPrototypeOf()就可以获取到这个对象的隐式原型，当然也可以直接访问这个对象的**proto**,但这个不在规范中，官方也不推荐使用，显式原型的就是比如我声明一个构造函数，那么这个构造函数就有 prototype 属性指向这个构造函数的显式原型，我们是可以往这个显示原型的挂在一些方法和属性，这样通过这个构造函数 new 的实例就可以访问到这个原型上的属性，做实例的隐式原型也指向构造函数的显式原型

原型链的话就是，构造函数的原型也拥有自己的原型，同时这个原型也肯有自己的原型，这样当我们在这个构造函数的一个实例上访问一个属性，会先在自身查找，找不到去原型上查找，还找不到去原型的原型上查找，知道找到为止，所有对象的原型都会指向 Object，找到最后没找到就会报找不到的错误，这样就形成了一条原型链，属性和方法也可以基于原型链查找，这也就是为什么 Object.prototype.toString.call()，可以判断基本数据类型和复杂数据类型的原因，所有对象在其原型链上都可找到 Object，自然可以调用该方法，基本数据类型通过 Object()被转为包装对象，自然也可以调用这个方法

原型链的作用一个是属性和方法的查找，还有一个是可以用来实现基于原型链继承

**prototype 与`__proto__`的关系与区别**

实例的`__proto__`,指向构造函数的 prototype,或者说实例的隐式原型指向构造函数的显式原型

区别就是一个针对实例的，一个是针对构造函数的，`__proto__`不是标准中规范的，可以使用 Object.getProtoType()代替

**继承的实现方式及比较**

继承的实现方式大致有五种：

第一种是通过原型链来实现继承，做法就是在子类的原型上挂载一个父类实例，这样就可以访问到父类的属性和方法，这种继承的问题在于对于引用数据类型内存空间是共享的，一个实例发送改变会引起其他实力也发生改变

第二种是通过构造函数来实现继承，具体做法就是在子类面通过 call，在在子类的上下文中执行父类，这样可以解决内存空间共享的问题，因为每个子类实例都是一个新的内存空间，但这样这样做的缺点是如果父类在原型上有方法，那么子类会继承不了

将上面两种方式结合形成第三种继承方式，组合式集成，但这样带来的问题是父类的的构造函数执行了两次，一次在子类的构造函数中，另一次是在网子类原型上挂在时，造成了一次不必要的开销，一个优化是直接将父类的原型挂载到子类原型上，这样少了一次开销，但同时引入了新的问题，子类的构造函数变成了父类，正常来说应该是子类

第四种是通过对象关联这样一种形式，通过 Object.create()来基于父类的原型创建子类，这叫做原型式继承，这样做的的缺点是内存空间共享问题

使用原型式继承可以获得一份目标对象的浅拷贝，然后利用这个浅拷贝的能力在进行增强就形成了寄生式继承，但依然存在内存空间共享的问题

第五种就是寄生式组合继承，在构函数里调用父类来解决内存空间共享，通过 Objec.create()来会的目标对象的一份浅拷贝，这就是最优的一种继承实现方式，既没有内存空间共享问题，也没有两次调用父类造成不必要开销的问题，并且 es6 中的 class 的 extend 也是基于这种方式实现的继承

关于继承的这几种实现代表了两种设计思想，一种通过继承的设计思想即父类子类这样，另一种是通过行为委托，并没有父子类之说，而是兄弟关系，JavaScript 的原型机制本身也就是行为委托，对象关联可以通过行为委托来实现

**深拷贝与浅拷贝**

浅拷贝就是讲一个对象拷贝给另一个对象时，对于基本数据类型，直接复制其值，对于复杂数据类型复制其指针，这就会造成修改拷贝的对象的引用数据类型，会影响到原来对象的相对应的引用数据类型，而深拷贝则是在拷贝时对于引用数据类型，完全申请了一块堆内存，将拷贝后的这个数据和原来的数据在内存上完全分离，不会出现浅拷贝那种内存空间共享的问题，深拷贝真正实现了二者的真正分离

浅拷贝的实现方式有许多，比如可以用过 Object.assign()，来实现浅拷贝，这个方法可以拷贝 Symbol 类型，但不会拷贝原型链上的和不可枚举的属性，还有一种是使用扩展运算符来实现浅拷贝，即可以对对象使用也可以对数组使用，针对数组的浅拷贝还可以使用 concat，slice

浅拷贝的一个实现思路：

```js
const copy = (obj) => {
  if (typeof obj === "object" && obj !== null) {
    const clone = Array.isArray() ? [] : {};
    for (let prop in target) {
      //for in 循环可遍历到可枚举以及原型上的属性
      if (target.hasOwnPrototy(prop)) {
        clone[prop] = obj[prop];
      }
    }
    return clone;
  } else {
    return obj;
  }
};
```

深拷贝可以通过 JSON 序列化反序列的方式来实现，但受到 json 数据格式的影响，对于一些特殊的数据不能处理，比如 undefined，Symbol，一些内置内类型比如日期和正则，日期会变成字符串，正则会变成空对象,还有不可枚举的拷贝不了，对象原型链拷贝不了，循环引用也解决不了

针对不可枚举的对象和 Symbol 可已通过 Reflect.ownKeys()方法获取，针对日期和正则直接生成一个新的实例返回，针对原型链上的属性可以通过 Object.getPropertyDescriptors 方法获得，因为他可以获得对象的所有属性，然后用 object.create(),创建一个新对象，针对循环引用可以使用 weakMap 作为一个哈希表，并且因为 weakMap 是弱引用可以避免内存泄漏

```js
const isComplexDateType(obj) => (typeof obj === "object" ||typeof obj ==="function") && obj !== null;
const copy = (obj,hash = new WeakMap()) => {
  if(obj.constructor === Date) return new Date(obj)
  if(obj.constructor === RegExp) return new RegExp(obj)
  if(hash.has(obj)) return hash.get(obj);
  let allDec = Object.getPrototyDescriptors(obj);
  let clone = Object.create(Object.getprototypeOf(obj),allDec);
  hash.set(obj,clone);
  for(let key of Reflect.ownKeys(obj)){
    clone[key] = isComplexDataType(obj[key]) && obj[key] !== "function";
    ? clone(obj[key],hash)
    :obj[key]
  }
  return clone
}
```

**防抖和节流**

略

**作用域和作用域链、执行期上下文**

作用域就是可以访问的代码中的变量和函数的范围

作用域链的作用是保证变量和函数的一个有序访问，通过作用域链，我们可以访问到外层的变量和函数，她的本质是一个指向变量对象的变量指针，变量对象包含了执行环境中的所有变量和函数，作用域链的始端指向当前作用域，终端指向全局作用域，当查找一个变量时，会现在当前作用域查找，找不到就沿着作用域链向上查找，作用域链的创建过程和执行上下文有关

执行上下文可以理解成一个对象，这个对象分三部分：变量对象，作用域链，this 指向，类型包含全局上下文，函数上下文和 eval 上下文

执行上下文其实是代码的一个执行环境，一段代码执行过程中，遇到了函数，会将函数上下文依次压入到执行占中，当函数执行完便会将这个函数上线文从执行栈中弹出，

**DOM 常见的操作方式**

dom 中的操作主要分为添加，删除，移动，复制，创建和查找

创建节点的方式主要有:createDocumentFragMent()创建一个 Dom 片段，createElement()创建一个具体的元素，createTextNode()创建一个文本节点

appendChild()添加操作，removeChild()删除操作,replaceChild()替换操作,insertBefore()插入

查找方法有:getElementById(),getElementByName(),getElementByTagName(),getElemenetByClassName(),querySeletor(),querySleectorAll()

属性操作：getAttribute(key),setAttribute(key, value),hasAttribute(key),removeAttribute()

**Array.sort()方法与实现机制**

Array,sort()，在不同的浏览器里底层是用的排序方法是不一样的，以 V8 为例，根据排序的元素个数会采用不同的排序方法：

当`n <= 10`时，采用差如排序，当 `n > 10`采用快速排序，当`10<n<=1000`,使用中位数作为哨兵元素，当`n>1000`每隔 200-215 个元素，放入到一个新数组中，对他排序，找到中间位置的数，以此作为中位数

元素少是使用插入排序因为插入排序在最好的情况下时间复杂度为 o(n),尽管平均复杂度为 o(n^2),快速排序平均复杂度为 o(nlogn),实际情况下两者的前面都一个系数，对于插入排序，若 n 足够小，速度会超过快排，插入排序在经过优化以后，对于小数据集会有非常优越的性能，所以这是选择插入排序是个不错的选择

快速排序的性能瓶颈在与递归的深度，最坏的情况是每次的哨兵都是最小的元素会最大的元素，在进行 partiton（一边是小于哨兵的元素，一边是大于哨兵的元素）那么就会有一边是空的，这么排下去递归层数就为元素的个数 n，时间复杂度会退化为 o(n^2),通过让哨兵元素尽肯能处于中间位置，减少最大或最小的情况，这就是 v8 对快速排序的一种优化

**Ajax 的请求过程**

使用 ajax 步骤大概是:

1. 创建 XMLHttpRequest 对象，这是一个异步调用对象
2. 然后创建一个新的 http 请求的方法，并指定该 HTTP 请求的方法，URL 及验证信息
3. 设置响应 http 请求状态变化的函数
4. 发送 http 请求
5. 获取异步返回的数据
6. 使用 JavaScript 和 Dom 实现局部刷新

如果是 post 可以通过`xhr.setRequestHeader("Content-type","application/x-www-from-urlencoded")`设置请求头

关于上面第三部的 http 的请求状态 readState，0 表示未初始化，1 表示服务器已建立连接，2 表示请求已收到，3 表示请求处理中，4 表示请求以完成，且响应已就绪

**JS 的垃圾回收机制**

js 中数据存储的位置有两种，一种是在栈中，另一种是在堆中，由于栈中的数据量都比较小，所以栈中的垃圾回收由操作系统来完成，js 中的垃圾回收机制只要针对的是堆内存

js 中有两个垃圾回收器，一个是副垃圾回收器，一个是主垃圾回收器，前者负责新生代中的垃圾回收，后者负责老生代中的垃圾回收

新生代中的垃圾回收机制是这样的，他主要回收哪些生命周期比较短的内存对象，所以需要一个效率非常高的算法，这个算法是一个牺牲空间来换取时间的算法，在占用空间不大的场景下非常适用，这个算法将内存分为两部分，一个 from space 一个是 to space，对 from space 中的活动对象进行标记，然后移动到 to space，并将这些对象有序的排列起来，然后将 from space 中的非活动对象进行释放，完成之后交换这两块，使得新生代中的这两块区域可以重复利用

新生代中的对象会通过晋升然后移动到老生代，在新生代中进一步划分了两个子区域，当我们第一次对内存进行分配时会被分配到其中一个子区域中，如果下一次垃圾回收这个对象还在新生代中，则会被移动到另一个子区域中，如果下一次垃圾回收这个对象还在新生代中，则这个对象会被移动到老生代

老生代中不能使用新生代中的垃圾回收算法，因为新生代中的算法为复制算法，重复复制活动对象效率低下，且是牺牲空间换时间的算法，老生带中的支持很大的容量，会出现资源浪费，所以老生代中主要使用标记清除和标记整理的算法

标记清除算法中先对老生代进行一次扫描，标记活动对象，然=然后进行第二次扫描，清理掉这些未被标记的对象，及非活动对象，这样会造成一个问题，被清除的对象遍布于各内存地址，产生了很多碎片，当需要分配一个很大的对象时，这些碎片空间无法完成分配，就会提前触发垃圾回收，而这次垃圾回收是不必要的，因此就有了标记整理的算法，他会将所有活动对象移项一端，然后直接清理掉边界外的内存

上面的垃圾回收当中当标记整理算法在移动活对象时可能对象比较多，她的执行速度不是很快，为了避免 js 的应用逻辑和垃圾回收器的资源竞争导致不一致的问题，这时垃圾回收器会将整个 JavaScript 应用暂停，这个过程叫做全停顿，而在新生代中由于空间小，存活对象较少，新生代的算法效率较快，所以全停顿并不影响，而老生带中活动对象较多，垃圾回收器全停顿的时间较长就会导致页面卡顿

为了解决上面那种卡顿 v8 通过增量标记和惰性清除，以及并发并行来降低主线程的挂在时间

增量标记就是将标记的过程穿插在 JavaScript 应用逻辑之间，允许标记的时间为 5~10ms，增量标记达到一定的阈值时才会启动，启动之后每当一定量的内存分配之后脚本的执行就会停顿进行一次增量标记

惰性清除用来真正释放内存，当增量标记完之后，加入当前的可用内存足以让我们的代码快速执行，其实我们是没有必要进行立即的清理内存的，可以将这个清理的过程延迟一下，让 js 代码先执行，也无需进行一次性的清理完所有非活动对象，垃圾回收器会逐一进行清理，直到所有都清理完毕

虽然增量标记和惰性清除是的主线程的最大停顿时间大大减少，也让用户与浏览器的交互过程流畅许多，但是每个小的标记之间执行了 js 代码堆中的变量的指针的可能发生了变化需要使用写屏障技术来保证这些引用关系的一致性，这就是增量标记的缺点：并没有减少主线程的总暂停时间甚至略微增加，由于写屏障技术机制的成本，增量标记可能会降低应用程序的吞吐量

并行式的 gc 可以使得辅助线程同时执行同样的 gc 工作，让辅助现成来分担主线程 gc 的工作，使得垃圾回收的耗时等于总时间除以参与线程的数量

目前 v8 的垃圾回收机制就是，副垃圾回收器使用并行机制，讲 from space 移动到 to space 时开启多个辅助线程，并行的进行整理，这会导致资源竞争，所以需要在每个对象复制完成后都去维护这个复制这个活动对象后的指针转发地址，以便于其他辅助线程可以找到该活动对象后判断该活动对象是否已被复制；对于主垃圾回收器，当堆中的内存大小超过阈值后，会并发的进行标记任务，每个辅助线程都会去追踪每个标记到的对象以及这个对象的引用，js 代码执行时，并发标记也会在后台的辅助线程中执行，当对象被修改时写入屏障技术会在辅助线程进行并发标记时进行追踪，当标记或动态分配的内存达到极限的时候，主线程会进行最终的快速标记步骤，这个时候主线程会挂起，主线程会再一次进行扫描确保所有对象都完成了标记，由于辅助线程已经标记过了活动对象，这次的扫描只是进行一次 check 操作，确认完成之后，有辅助线程进行内存的整理和清除，由于都是并行的，所以并不会影响主线程的执行

**JS 中的 String、Array 和 Math 方法**

String : split,slice,substr,trim,concat,indexOf ,lastIndexOf

Array:····

Math：有一些常量和一些方法，都是与数学运算有关的

**addEventListener 和 onClick()的区别**

onclick 是 Dom0 的绑定事件的方式，而 addEventLister 是 Dom2 绑定事件的方式，使用 onclick 绑定的事件解绑需要将 onclick 设为 null，而 addEventListener 绑定的事件解绑需要 removeEventListerk 来解绑

onclick 绑定事件有点有：简洁，处理事件 this 指向当前元素，缺点是不能对事件进行捕获和冒泡进行控制，只能使用事件冒泡而不能使用事件捕获，并且一次只能对一个元素绑定一个事件处理程序，当使用 window.onload 时，会覆盖采用相同方法所绑定的事件

addEventListener 的优点就是支持捕获与冒泡，通过最后一个参数来设置，默认值为 false 表示事件冒泡，设置为 true 表示事件捕获，她的 this 和 onclick 一样，事件处理函数中，event 对象总是作为第一个可用参数，可以绑定多个事件而不会发生覆盖，缺点是 ie8 不支持

**new 和 Object.create 的区别**

new 操作所做的工作有：

- 创建一个对象
- 对新对象进行原型操作，指向构造函数的原型
- 将 this 绑定到新对象上
- 如果构造函数返回了一个对象，就返回这个对象，否则返回新对象

object.create 所做的工作有：

该方法有两个参数，第一个参数作为新建对象的原型，第二个参数是一个对象，该对象的属性名称是新创建的对象的属性名称

- 创建一个新对象
- 将新对象的`__proto__`指向传入的参数
- 将传入的对象属性复制到新对象并返回新对象

从他们的内部所做的工作可以看出 new 是保留了构造函数，而 object.create()没有，原型链方面，new 保留了原构造函数的 prototype 属性，而 object.create 就是原构造函数或对象本身，new 作用的对象只能是函数，而 object.create 可以是函数也可以是对象

**DOM 的 location 对象**

window.location 是一个只读属性，返回一个 location 对象，其中包含有文档当前的位置信息，包括 hash，search,host,hostname,href,origin 等等,还有一些方法比如reload，replace，assign

尽管他是一个只读对象，仍然可以赋值给他一个 DOMString，这意味着可以再大多数情况下处理 location，就像它是一个字符串一样：

`window.location = 'http://www.example.com'`，是 `window.location.href = 'http://www.example.com'`的同义词

reload强制从服务器从新加载当前页面，replace重新加载页面，assign使用新的url加载页面

**浏览器从输入 URL 到页面渲染的整个流程（涉及到计算机网络数据传输过程、浏览器解析渲染过程）**

网络层面，首先，域名是对ip地址的映射，所以这里也有一个DNS解析的过程，DNS也会存在缓存，首先是浏览器缓存，然后是系统缓存，然后是路由器缓存，然后是运营商缓存，根域名服务器，再到顶级域名服务器，主域名服务器逐一读取，DNS的查询方式有两种一种是递归查询，从客户端到DNS服务器是属于递归查询的，而DNS服务器之间的交互查询是迭代查询，然后会建立tcp链接经历三次握手，然后进行http链接，构建请求构建请求行，`GET / HTTP/1.1`,查找强缓存，强缓存失效，使用协商缓存，得到服务端的响应，到这网络层面结束

解析层面，浏览器收到服务端传过来的html文件的字节流，先进行字节流的一个解码，这样才能看到字符串，然后进行输入流预处理，主要是生成规范化的字符流数据，然后是令牌化，将字符流解析成标签和文本节点，然后根据上一步的操作进行Dom树的构建，在这当中若遇到script标签会根据script加载的方式进行不同的处理，当script标签中改变了DOM的结构，则会将这些改变的代码加入到字符流重新进行解析，dom树构建完会进行CSSOM树的构建

渲染方面，有了cssom树和dom树会计算布局，并生成布局树，然后对于一些复杂的场景比如动画，会有层叠上下文，这是会进行图层树得构建，接下来渲染引擎会将图层拆分成一个一个绘制指令，生成绘制列表，然后由合成线程进行绘制，考虑到视口很大不可能一下子绘制完，所以会对图层进行分块，渲染进程还会专门维护一个栅格化线程池专门负责把图块转换成位图数据，这个过程要进入到GPU当中进行加速并生成位图然后返回给合成线程，由于上传GPU会比较慢，chrom采取了一个优化首屏加载速度操作，回先展示一个分辨率比较低的图片，最后显示器显示内容，合成线程生成绘制指令，发送给浏览器进程，浏览器受到这个命令把页面内容绘制到内存，也就是生成了页面，再把这部分内存发送给显卡，显卡接收到后会合成相应的图像，并将图像保存到缓冲区

所以当动画过多占用大量内存，浏览器生成图像变慢，传递给显卡不及时，显示器以不变的频率刷新，就会出现掉帧现象

**跨域、同源策略及跨域实现方式和原理**

跨域之所以出现是因为浏览器为了保证安全而制定的一个同源策略，浏览器之外是不存在跨域的，同源策略是一个域去访问另一个域中的资源是会被禁止，同源要求ur协议，主机名，端口都相同

解决跨域一般有四种方式：第一种是通过跨域资源共享，这种是在服务端进行解决，第二种是使用jsonp，这种方式的缺点是只能发get请求，不能捕获服务端的错误，并且请求过程无法终止，是利用了浏览器对script标签没有同源策略的限制来实现的，第三种是通过webscort来解决跨域，这是因为他是个全双工协议，不是同源策略限制，最后一种是通过代理转发的方式，比如webpack的devserve，nginx配置proxy_pass

还有一种跨域是父子页面的跨域，例如使用iframe来进行父子页面之间的通信，这是可以使用，postMessage来进行通信，也可以用过改域的方式来解决，将document.domain改成更高的父域

**浏览器的回流（Reflow）和重绘（Repaints）**

重绘是渲染树中一些元素需要更新属性，而这些属性只影响外观，风格，不会影响布局的操作，比如背景色这样的操作成为重绘

回流当渲染树中一部分因为尺寸，规模，布局，隐藏等改变而需要重新构建的操作，会影响到布局的操作，这样的操作我们称之为回流

重绘由于没有影响到布局，所以只进行了样式计算而跳过了布局树和建图层树的过程，直接生成绘制列表，然后继续进行分块，生成位图等后面一些类操作

回流会将样式计算后一系列操作重新执行一遍，开销是比较大的，并且回流一定会重绘，但重绘不一定会回流

那么避免回流可以这样组：

+ 使用transfrom代替top
+ 进行防抖节流处理
+ DOM离线修改，使用documentFragment对象在内存中操作Dom
+ 避免频繁使用style，而是使用class
+ 添加will-change:transform,让渲染进程单独实现一个图层，仅仅利用合成线程去处理，不牵涉到主线程，大大提高渲染效率

**JavaScript 中的 arguments**

他是一个类数组，使用typeof 返回 [object argumengt],他作为函数的参数对象，内部有callee返回函数本身，可以使用显示绑定this的方式借用数组上的方法，也可以将它转换成数组


**EventLoop 事件循环**



**宏任务与微任务**
**BOM 属性对象方法**

对象：Window，document，location，screen，history，navigator。 

方法：Alert()，confirm()，prompt()，open()，close()

**函数柯里化及其通用封装**
**JS 的 map()和 reduce()方法**
**“==”和“===”的区别**
**setTimeout 用作倒计时为何会产生误差？**

## ES6
**let、const和var的概念与区别**
**变量提升与暂时性死区**
**变量的结构赋值**
**箭头函数及其this问题**
**Symbol概念及其作用**
**Set和Map数据结构**
**Proxy**
**Reflect对象**
**Promise（手撕Promise A+规范、Promise.all、Promise相关API和方法）**
**Iterator和for...of（Iterator遍历器的实现）**
**循环语法比较及使用场景（for、forEach、for...in、for...of）**
**Generator及其异步方面的应用**
**async函数**
**几种异步方式的比较（回调、setTimeout、Promise、Generator、async）**
**class基本语法及继承**
**模块加载方案比较（CommonJS和ES6的Module）**
**ES6模块加载与CommonJS加载的原理**

## HTML/CSS
**CSS权重及其引入方式**
**`<a></a>`标签全部作用**
**用CSS画三角形**
**未知宽高元素水平垂直居中（方案及比较）**
**元素种类的划分**
**盒子模型及其理解**
**定位方式及其区别（文档流）**
**margin塌陷及合并问题**
**浮动模型及清除浮动的方法**
**CSS定位属性**
**display及相关属性**
**IFC与BFC**
**圣杯布局和双飞翼布局的实现**
**Flex布局**
**px、em、rem的区别**
**Less预处理语言**
**媒体查询**
**vh与vw**
**H5的语义化作用及语义化标签**
**Web Worker和Web Socket**
**CSS3及相关动画**
**如何实现响应式布局**
**SEO的概念及实现**
**HTML5的新特性**
**Less和Sass使用**

## HTTP 与计算机网络

## 前端工程化

## React

## NodeJs

## 手撕代码
