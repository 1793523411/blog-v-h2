---
time: 2021-02-27
icon: template
category: ç®—æ³•
article: true
sidebar: auto
footer: ğŸ˜ğŸ˜ğŸ˜
tag:
  - ç®—æ³•
---

# åºåˆ—åŒ–äºŒå‰æ ‘

```
è¯·å®ç°ä¸¤ä¸ªå‡½æ•°ï¼Œåˆ†åˆ«ç”¨æ¥åºåˆ—åŒ–å’Œååºåˆ—åŒ–äºŒå‰æ ‘ã€‚

ç¤ºä¾‹:Â 

ä½ å¯ä»¥å°†ä»¥ä¸‹äºŒå‰æ ‘ï¼š

    1
   / \
  2   3
     / \
    4   5

åºåˆ—åŒ–ä¸º "[1,2,3,null,null,4,5]"
```

## BFS

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
const serialize = (root) => {
  const queue = [root];
  let res = [];
  while (queue.length) {
    const node = queue.shift(); // è€ƒå¯Ÿå‡ºåˆ—çš„èŠ‚ç‚¹
    if (node) {
      // æ˜¯çœŸå®èŠ‚ç‚¹ï¼Œå¸¦å‡ºå­èŠ‚ç‚¹å…¥åˆ—
      res.push(node.val); // èŠ‚ç‚¹å€¼æ¨å…¥res
      queue.push(node.left); // å­èŠ‚ç‚¹å…¥åˆ—ï¼Œä¸ç®¡æ˜¯ä¸æ˜¯nullèŠ‚ç‚¹éƒ½å…¥åˆ—
      queue.push(node.right);
    } else {
      // æ˜¯nullèŠ‚ç‚¹ï¼Œæ²¡æœ‰å­èŠ‚ç‚¹å…¥åˆ—
      res.push("X"); // X æ¨å…¥res
    }
  }
  return res.join(","); // è½¬æˆå­—ç¬¦ä¸²
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
const deserialize = (data) => {
  if (data == "X") return null;

  const list = data.split(","); // åºåˆ—åŒ–å­—ç¬¦ä¸²splitæˆæ•°ç»„

  const root = new TreeNode(list[0]); // è·å–é¦–é¡¹ï¼Œæ„å»ºæ ¹èŠ‚ç‚¹
  const queue = [root]; // æ ¹èŠ‚ç‚¹æ¨å…¥é˜Ÿåˆ—
  let cursor = 1; // åˆå§‹æŒ‡å‘listç¬¬äºŒé¡¹

  while (cursor < list.length) {
    // æŒ‡é’ˆè¶Šç•Œï¼Œå³æ‰«å®Œäº†åºåˆ—åŒ–å­—ç¬¦ä¸²
    const node = queue.shift(); // è€ƒå¯Ÿå‡ºåˆ—çš„èŠ‚ç‚¹

    const leftVal = list[cursor]; // å®ƒçš„å·¦å„¿å­çš„å€¼
    const rightVal = list[cursor + 1]; // å®ƒçš„å³å„¿å­çš„å€¼

    if (leftVal != "X") {
      // æ˜¯çœŸå®èŠ‚ç‚¹
      const leftNode = new TreeNode(leftVal); // åˆ›å»ºå·¦å„¿å­èŠ‚ç‚¹
      node.left = leftNode; // è®¤çˆ¶äº²
      queue.push(leftNode); // è‡ªå·±ä¹Ÿæ˜¯çˆ¶äº²ï¼Œå…¥åˆ—
    }
    if (rightVal != "X") {
      const rightNode = new TreeNode(rightVal);
      node.right = rightNode;
      queue.push(rightNode);
    }
    cursor += 2; // ä¸€æ¬¡è€ƒå¯Ÿä¸€å¯¹å„¿å­ï¼ŒæŒ‡é’ˆåŠ 2
  }
  return root; // BFSç»“æŸï¼Œæ„å»ºç»“æŸï¼Œè¿”å›æ ¹èŠ‚ç‚¹
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```

## DFS

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */

/**
 * Encodes a tree to a single string.
 *
 * @param {TreeNode} root
 * @return {string}
 */
const serialize = (root) => {
  if (root == null) {
    // éå†åˆ° null èŠ‚ç‚¹
    return "X";
  }
  const left = serialize(root.left); // å·¦å­æ ‘çš„åºåˆ—åŒ–ç»“æœ
  const right = serialize(root.right); // å³å­æ ‘çš„åºåˆ—åŒ–ç»“æœ
  return root.val + "," + left + "," + right; // æŒ‰  æ ¹,å·¦,å³  æ‹¼æ¥å­—ç¬¦ä¸²
};

/**
 * Decodes your encoded data to tree.
 *
 * @param {string} data
 * @return {TreeNode}
 */
const deserialize = (data) => {
  const list = data.split(","); // splitæˆæ•°ç»„

  const buildTree = (list) => {
    // åŸºäºlistæ„å»ºå½“å‰å­æ ‘
    const rootVal = list.shift(); // å¼¹å‡ºé¦–é¡¹ï¼Œè·å–å®ƒçš„â€œæ•°æ®â€
    if (rootVal == "X") {
      // æ˜¯Xï¼Œè¿”å›nullèŠ‚ç‚¹
      return null;
    }
    const root = new TreeNode(rootVal); // ä¸æ˜¯Xï¼Œåˆ™åˆ›å»ºèŠ‚ç‚¹
    root.left = buildTree(list); // é€’å½’æ„å»ºå·¦å­æ ‘
    root.right = buildTree(list); // é€’å½’æ„å»ºå³å­æ ‘
    return root; // è¿”å›å½“å‰æ„å»ºå¥½çš„root
  };

  return buildTree(list); // æ„å»ºçš„å…¥å£
};

/**
 * Your functions will be called as such:
 * deserialize(serialize(root));
 */
```
