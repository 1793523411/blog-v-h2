---
time: 2021-03-18
icon: template
category: 面试
article: false
sidebar: auto
footer: 😁😁😁
tag:
  - 前端
---

# Niuke's previous front-end knowledge summa（down）

[[toc]]

## HTTP 与计算机网络

### TCP/IP 协议分层管理

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/0fa6c237-a909-4e2a-a771-2c5485cd8ce0.png)

五层协议：

应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。

传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。

网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。

数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。

物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异

### 三次握手四次挥手机制及原因

**三次握手**

第一次握手是让服务端知道客户端具有发送能力，第二次握手是让客户端知道服务端具有接受和发送的能力，但此时服务端并不知道客户端是否收到了自己发送的消息，所以第三次握手起到了这个作用，经过了三次握手后服务端和客户端都确认了双方的接收和发送能力

不是两次是因为无法确认客户端的接受能力，大于等于三次都可以，只是再多用处不大，第三次握手是可以携带数据的，前两次不可以，因为有人想攻击服务器，在第一次握手中放了大量数据，那么服务端必定会消耗更多的时间和内存去处理这些数据，大大增加了服务端被攻击的风险

第一次握手，客户端处于 close 状态，服务端处理 listening 状态，客户端给服务端发送了一个 SYN 报文并指明了客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态

第二次握手，服务端接收到 SYN 报文后，会以自己的 SYN 报文作为应答，并且也指定了自己的初始化序列号 ISN，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务端处于 SYN_REVD 状态

第三次握手，当客户端接收到 SYN 报文后，会发送一个 ACK 报文，也把 ISN + 1 作为 ACK 的值，表示客户端接收到了服务端的 SYN 报文，此时客户端处于 establish 的状态，服务端接收到 ACK 报文后也处于 established 状态，此时双方成功建立起链接

**四次挥手**

为什么链接需要三次而断开需要四次：当服务端接收到客户端的 FIN 报文后，发送的 ACK 报文还是用来应答，并不表示服务端也希望立即关闭连接，只有当服务端把所有的报文都发送完了，才会发送 FIN 报文，告诉客户端可以断开连接了，因此这就是需要四次挥手的原因

第一次挥手，在挥手之前，两端都处于 established 的状态，客户端发送一个 FiN 报文，用来关闭客户端到服务端的数据传输，此时客户端处于 FIN_WAIT_1 状态。

第二次挥手，当服务端收到 FIN 报文后，会发送 ACK 报文，并把客户端的序列号值加 1 作为 ACK 报文的序列号，表明已经收到客户端的报文了，此时服务端处于 close_wait 状态

第三次挥手，如果服务端同意关闭连接，则会向客户端发送一个 FIN 报文，并指定一个序列号，此时服务端处于 LAST_ACK 的状态

第四次挥手，当客户端收到 ACK 后，处于 FIN_WAIT_2 状态，待收到 FIN 报文时发送一个 ACK 报文作为应答，并且把服务端的序列号值+1 作为自己的 ACK 报文的序列号值，是客户端处于 TIME_WAIT 状态，等待一段时间后会进入 closed 状态，当服务端接收到 ACK 值后，也会变为 closed 状态，此时连接正式关闭

### HTTP 方法

- GET:通常用来获取资源
- HEAD：获取资源的元信息
- POST：提交数据，即上传数据
- PUT：修改数据
- DELETE：删除数据
- CONNECT：建立连接隧道，用于代理服务器
- OPTIONS:列出可对资源实行的请求方法，用来跨域请求
- TRACE：追踪请求-响应的传输路径

### GET 和 POST 的区别

最直观的是语义上的区别，往细了说：

- 从缓存角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 post 请求不会
- 从编码角度，get 请求只能进行 URL 编码，只能收到 ASCII 字符，而 POST 没有限制。
- 从参数角度，get 请求一般会放到 URL 中，因此不安全，post 请求放在请求体中，更适合传输敏感信息
- 从幂等性角度，get 是幂等性的，而 post 不是（幂等性是指执行相同的操作，结果也是相同的）
- 从 TCP 的角度，get 请求会吧请求报文一次性的发出去，而 Post 会分为两个 TCP 数据包，首先发送 header 部分，如果服务器响应 100，然后发 boy（火狐浏览器除外，她的 post 请求只发一个 TCP 包）

### HTTP 建立持久连接的意义

HTTP 建立持久连接是在 HTTP1.1 版本中才有的，HTTP1.0 通过设立头部字段来进行不同类型文件的传输，随着互联网的发展，HTTP1.0 已经无法满都需求，最核心的问题就是连接问题，具体来说就是每进行一次通信都要进行建立连接，传输数据，断开连接的过程三个阶段，当一个页面引用了较多的外部文件时，这个建立连接和断开连接的过程就会增加大量的网阔开销

为了解决这个问题，http1.1 版本增加了一个创建之持久连接的方法，实现了每当一个连接传输完成时，并不是马上进行关闭，而是继续复用他传输其他请求，这个链接直到浏览器或者服务器要求断开为止

### HTTP 报文的结构

http 报文结构是 header+body 的结构，大致为起始行+头部+空行+实体

起始行对于请求报文来说是`请求方法 路径 http版本`，对于响应报文是`http版本 状态码 原因`，起始行中每两个部分之间用空格隔开，最后一个部分后面接一个换行符

不管是请求头韩式响应头，其中的字段是相当多的，牵扯到 http 非常多的特性，格式方面：

- 字段名不区分大小写
- 字段名不允许出现空格，不可以出现下划线
- 字段名后面必须紧跟着:

空行很重要，用来区分头部和实体，如果故意在头部中间加一个空行，那么空行后面的内容会全部被视为实体

最后实体就是 body 部分了，请求报文对应请求体，响应报文对应响应体

### HTTP 状态码

http 状态码为三位数，被分为 5 类：

- 1xx 表示目前是协议的中间状态，还需要后续操作
- 2xxx 表示成功状态
- 3xx 是重定向状态，资源位置发生变动，需要重新请求
- 4xx 是请求报文有误
- 5xx 是服务端发生错误

常见的状态码有这些：

- 200 表示成功的状态码
- 204 表示请求成功但响应头后没有 body 数据
- 206 表示部分内容，使用场景为 http 分块下载和断点续传，当然也会带上相应的响应头部字段 Content-Range
- 301 永久重定向，302 临时重定向
- 304 表示命中协商缓存
- 400 笼统的提示一下，并不知道哪里出错了
- 403 表示服务器禁止访问
- 404 表示未在服务器上找到资源
- 405 表示请求方法不被允许
- 406 表示资源无法满足客户端的条件
- 408 表示服务器等待时间过长
- 409 表示多个请求发生了冲突
- 413 表示请求体数据过大
- 414 表示请求行里的 URL 太大
- 429 表示客户端发送的请求过多
- 431 表示请求字段内容太大
- 500 表示服务器出错了，但不知道出了什么错
- 501 表示客户端请求的功能还不支持
- 502 表示服务器本身正常，但访问时出错了，具体什么错误不知道
- 503 表示服务器当前很忙，暂时无法响应服务

### Web 服务器及其组成

Web 服务器一般指网站服务器，是指驻留于因特网上某种类型计算机的程序，可以处理浏览器等 Web 客户端的请求并返回相应响应，也可以放置网站文件，让全世界浏览；可以放置数据文件，让全世界下载，目前最主流的三个 Web 服务器是 Apache、 Nginx 、IIS

Web 服务器有以下几个部分组成：

- 服务器初始化部分，这部分主要完成初始化的工作，比如建立守护进程，创建 TCP 套接字，绑定端口，等待接收客户端的连接
- 接收客户端请求，http1.x 中以文本行的形式接收，因为请求头是以文本行的方式实现的
- 解析客户端请求，解析出请求方法，url 目标，可选的查询信息以及表单信息，如果请求方法为 HEAD，则简单的返回响应首部即可；如果方法是 GET，则首先返回响应首部，然后将客户端请求的 URL 目标文件从服务器磁盘上读取，再发送给客户端；如果是 POST，则比较麻烦，首先要调用相应的 CGI 程序，然后将用户表单信息传给 CGI 程序，CGI 程序根据表单内容完成相应的工作，并将结果数据返回
- 发送响应信息后，关闭与客户端的链接

### HTTP 的特点

- 灵活扩展，语义上很自由，没有严格的语法限制，传输形式多样
- 可靠传输，将 TCP 的这一特性继承了下来
- 请求-应答，一收一发，有来有回
- 无状态，指的是通信过程中的上下文信息，每次 http 请求都是独立，无关的，默认不需要保留状态信息

缺点：

- 无状态，在长链接中，需要保存大量的上下文信息，一面传输大量的重复信息，这时无状态就成了缺点，而少量的数据传输不需要保存上下文信息，无状态减少了网络开销，就是无状态的优点
- 明文传输，报文都是文本形式，而不是使用的二进制形式，报文信息暴露给外界，方便调试的同时也给了攻击者方便，比如 wifi 陷阱
- 队头阻塞问题，当开启长连接，多个请求共用一个 TCP，同一时刻只能处理一个请求，那么如果当前请求耗时过长，其它请求就只能处于阻塞状态

### HTTP 通用首部字段

**http 有一个 accept 系列的字段：**

http 可以使用 `content-type` 这个字段来指定 body 部分的数据类型，这是针对发送端而言的，接收端想要接受特定的数据类型可以使用 accept 字段，这两个字段的取值有

- text:text/html,text/plain,text/css
- image:image/gif,/image/jpeg,image/png
- audio/xideo:audio/mpeg,video/mp4
- application:application/json,application/javascript,application/pdf,application/octet-stream

http 可以通过头部字段指定压缩方式客户端使用 `Content-Encoding`，接收端使用 `Accept-Encoding`，这个字段的取值

- gzip：当今最流行的压缩格式
- deflate：另外一种著名的压缩格式
- br：一种专门为 http 指定的压缩算法

http 可以通过头部字段指定所支持的语言，客户端使用 `Content-Language`，接收方使用 `Accept-Language`

- Content-Language：zh-CN,zh,en
- Accept-language:zh-CN,zh,en

http 可以通过头部指定字符集，客户端没有使用 `Content-Charset`，而是直接放在了 `Content-Type` 中并使用 `charset` 指定，接收端使用 `Accept-charste`

- content-Type：text/html;charset=utf-8
- Accept-Charset:charset=utf-8

**对于定体包长，发送端在传输时一般会带上 `Content-Length` 来指明包体长度，对于不定体包长，http 使用`Transfer-Encoding：chunked`来表示分块传输，这个字段产生两个效果：Content-Length 被忽略和基于长连接的持续推送动态内容，此时响应头中会有 Connectton:keep-alive，响应体是下面这样**

```
chunk长度(16进制的数)
第一个chunk的内容
chunk长度(16进制的数)
第二个chunk的内容
```

**传输大文件时不可能一次传输完，所以允许客户端仅仅请求一个资源的一部分，同时服务端要支持范围请求，`Accept-Ranges:none`字段来告知客户端服务端是支持范围请求的，对于客户端而言需要指定请求哪一部分，可用过`Range:byte=x-y`的格式来表示，服务端收到请求后先验证返回是否合法，如果越界了，返回 416 状态码，否则读取相应的片段返回 206 状态码，通过这个字段可以设置请求是单端数据还是多段数据,**

```
// 单段数据
Range: bytes=0-9
// 多段数据
Range: bytes=0-9, 30-39
```

同时，服务器需要添加 Content-Range 字段，这个字段的格式根据请求头中 Range 字段的不同

```
HTTP/1.1 206 Partial Content
Content-Length: 10
Accept-Ranges: bytes
Content-Range: bytes 0-9/100

i am xxxxx
```

```
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000010101
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes


--00000010101
Content-Type: text/plain
Content-Range: bytes 0-9/96

i am xxxxx
--00000010101
Content-Type: text/plain
Content-Range: bytes 20-29/96

eex jspy e
--00000010101--
```

多段数据中有一个`Content-Type：multipart/byteranges;boundary=00000010101`，来指定响应体中多端数据的分隔符，而且在最后的分隔末尾添上`--`表示结束

**对于表单数据设置 Content-Type 为`application/x-www-form-urlencodind`或`multipart/form-data`,前者的数据会被&分割成以`&`分隔的键值对，字符以 URL 编码的方式编码，后者的数据会被分割为多个部分每个部分之间会有分隔符来分割，每部分头部均有 http 又不描述子包体**

```
前者
// 转换过程: {a: 1, b: 2} -> a=1&b=2 -> 如下(最终形式)
"a%3D1%26b%3D2"

后者
Content-Disposition: form-data;name="data1";
Content-Type: text/plain
data1
----WebkitFormBoundaryRRJKeWfHPGrS4LKe
Content-Disposition: form-data;name="data2";
Content-Type: text/plain
data2
----WebkitFormBoundaryRRJKeWfHPGrS4LKe--
```

::: tip
multipart/form-data 格式最大的特点在于:每一个表单元素都是独立的资源表述,浏览器和 HTTP 封装了 boundary

在实际的场景中，对于图片等文件的上传，基本采用 `multipart/form-data` 而不用 `application/x-www-form-urlencoded`，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间
:::

### HTTP 的队头阻塞

HTTP 传输是基于请求-应答的模式进行的，报文必须一发一收，里面任务是被放在任务队列中串行执行的，一旦队首的请求处理太慢，就会阻塞后面的请求

**并发连接**

一个域名允许分配多个长连接，相当于增加了任务队列，不至于在一个队列里阻塞，但 RFC 规定客户端最多并发两个连接，实际上在 Chrome 浏览器中允许 6 个连接

**域名分片**

既然一个域名可以并发六个连接，就多适用几个域名，一级域名下可以有多个二级域名，可以都指向同一台服务器，这样就增加了长连接的并发数

### Cookie 相关首部字段

关于 http 的无状态可以用 cookie 来解决，cookie 是一个上限大小为 4kb 的一个很小的文本，用键值对的形式存储信息，向同一个域名下发送请求时**都会带上相同的 cookie**，服务端拿到 cookie 就等于拿到了客户端的状态

服务端可以通过`set-cookie`作为响应头来对客户端进行 cookie 的写入，客户端通过`cookie`字段传递 cookie 给服务端

**生命周期**

通过`Exprise`和`Max-Age`来设置，前者是过期时间，基于时间戳，后者是一段时间间隔单位是秒,cookie 过期就会被删除，并不会发送给服务端

**作用域**

作用域有两个属性：`Domain`和`path`，分别给 cookie 绑定域名和路径，在发送请求时发现域名或路径和这两个属性不匹配，就不会带上 cookie，但对于`/`来说，任意路径都允许 cookie，因为他表示根路径

**安全相关**

如果带上 Secure 表示只能通过 HTTps 传输 cookie

如果带上 HttpOnly 则只能通过 HTTP 协议传输，而不能通过 js 访问，这也是预防 XSS 的重要手段

相对 CSRF 的防御，可以设置 SameSite 属性，他有三个值：

1. strict，完全禁止第三方请求携带 cookie
2. Lax，宽松了一点，但只能在 get 方法提交表单或 a 标签发送 get 请求的情况下可以携带 cookie，其他情况局不能
3. None，默认模式，请求自动带上 cookie

cookie 的去电主要就是容量比较小，然后就是紧跟域名，不管是否需呀都会带上，随着请求数的真多就会造成不必要的浪费，这个可以通过设置作用域来解决，最后一点是它是以文本形式进行传输的，很容易被非法获取，另外 HTTPOnly 为 false 的情况下，cookie 也能获取到 cookie1，也是一个安全隐患

### HTTPS 与 HTTP 区别及实现方式

[https](http://vhblog.ygjie.icu/zh/essay/21/#https)

### Cookie 与 Session

- Session 是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中；

- Cookie 是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现 Session 的一种方式。

本来 session 是一个抽象概念，开发者为了实现中断和继续等操作，将 user agent 和 server 之间一对一的交互，抽象为“会话”，进而衍生出“会话状态”，也就是 session 的概念。

而 cookie 是一个实际存在的东西，http 协议中定义在 header 中的字段。可以认为是 session 的一种后端无状态实现。而我们今天常说的 “session”，是为了绕开 cookie 的各种限制，通常借助 cookie 本身和后端存储实现的，一种更高级的会话状态实现。

所以 cookie 和 session，可以认为是同一层次的概念，也可以认为是不同层次的概念。具体到实现，session 因为 session id 的存在，通常要借助 cookie 实现，但这并非必要，只能说是通用性较好的一种实现方案。

### 基于 HTTP 的功能追加协议（SPY、WebSocket、HTTP）

Websocket 和 HTTP 都是基于 TCP 协议两个不同的协议

首先 Websocket 是一种在单个 TCP 连接上进行全双工通信的协议，允许服务端主动向客户端推送数据（只需要一次握手，两者之间创建持久化连接，可进行双向数据传输）；而 HTTP 则需要定时轮询向服务器请求，然后服务器再向客户端发送数据

其次，HTTP 是一个无状态协议，缺少状态意味着后续处理需要先前数据必须重传；而 Websocket 需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息

应用场景：如果应用是多个用户相互交流，或者展示服务端经常变动的数据都可以考虑 websocket；所以体育实况，多媒体聊天等这些都是 Websocket 不错的应用场景

### TCP 与 UDP 区别

TCP 是一个面向连接的、可靠的、基于字节流的传输层协议。

而 UDP 是一个面向无连接的传输层协

具体来分析，和 UDP 相比，TCP 有三大核心特性:

1. 面向连接。所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP 需要三次握手建立连接，而 UDP 没有相应建立连接的过程。
2. 可靠性。TCP 花了非常多的功夫保证连接的可靠，这个可靠性体现在哪些方面呢？一个是有状态，另一个是可控制。TCP 会精准记录哪些数据发送了，哪些数据被对方接收了，哪些没有被接收到，而且保证数据包按序到达，不允许半点差错。这是有状态,当意识到丢包了或者网络环境不佳，TCP 会根据具体情况调整自己的行为，控制自己的发送速度或者重发。这是可控制,相应的，UDP 就是无状态, 不可控的
3. 面向字节流。UDP 的数据传输是基于数据报的，这是因为仅仅只是继承了 IP 层的特性，而 TCP 为了维护状态，将一个个 IP 包变成了字节流

### 存储机制 localStorage、sessionStorage 与 Cookie 存储技术

[浏览器存储](http://vhblog.ygjie.icu/zh/essay/17/)

### XSS 攻击及防御

XSS 全称是跨站脚本攻击，为了和 css 区别就叫 XSS，这种攻击是在浏览器中执行恶意脚本，，从而拿到用户操作并进行操作

一般会有这些操作：

- 盗取 cookie
- 监听用户行为，获取用户的输入密码
- 修改 DOM 伪造表单
- 生成广告

有三种类型：存储型，反射型，文档型

存储型就是将而恶意脚本存起来，存到了服务端的数据库，然后在客户端执行脚本，从而达到了攻击的效果，预防的话主要就是对前端进行一些转义，因为他攻击方式就是在客户端执行了恶意的 js 代码

反射型是将恶意脚本作为网络请求的一部分，将恶意代码作为 url 的参数，服务端会拿到这个参数，然后将内容返回给浏览器，浏览器将这些内容作为 html 的内容，发现是一个脚本就直接执行

文档型的攻击不经过服务端，而是作为中间人的角色，在数据传输过程中劫持到网络数据包，然后修改里面的 html 文档，劫持方式有 WiFi 路由器和本地恶意软件等

三种攻击方式的原理，有一个共同点就是让恶意脚本在浏览器中执行，防范就要避免这些恶意脚本的执行：做到一个信念，两个利用

一个信念是不要相信客户端的输入，这就要求对输入的代码进行转义或过滤，这样恶意代码就无法执行了，两个利用是利用 CSP 和利用 HttpOnly，csp 是浏览器的安全策略

csp 是浏览器的内容安全策略，核心思想是决定浏览器加载哪些资源：1.限制其他域下的资源加载，2.禁止其他域提交数据，3.提供上报机制，能帮助我们及时发现 XSS 攻击

httpOnly 可以 XSS 脚本窃取 cookie 来进行攻击，httpOnly 设置为 true 可以是的 JavaScript 无法读取 cookie

### CSRF 攻击及防御

CSRF 即跨站请求伪造，指的是黑客诱导用户点击链接，打开黑客的网站，然后黑客利用用户的登录状态发起跨站请求

诱导用户的可能是小姐姐图片，或其他什么的，可能是图片也可能是链接

点击链接之所以会发生攻击是因为做了一些事情

1. 自动发起 get 请求，这种请求会自动带上用户的 cookie，而这个 cookie 信息保存了用户的登录状态，加入服务器没有任何验证机制，就会以为这是一个正常用的的请求，然后就可以进行一些列操作
2. 自动发起 post 请求，黑客可能自己填了一个表单，和一个自动提交表单的脚本，同样是利用 cookie 从而使用用户的登录状态来进行恶意操作

因为主要是利用了 cookie 来进行攻击的，所以就可以在 cookie 上来防范

可以利用 cookie 的 sameSite 属性为 strict 来禁止第三方请求携带 cookie

也可以通过在服务端验证站点来源，需要要用到请求头中的两个字段: Origin 和 Referer，来控制 cookie 的作用域，但是这两者是可以伪造的

还有一种方法使用 CSRF Token，原理大致是，浏览器向服务端发送请求时，服务器会生成一个字符串植入到返回的页面中，如果浏览器要发送请求必须带上这个字符串，然后由服务端来验证是否合法，不合法就不给予响应，通常第三方无法拿到这个 token

## 前端工程化

### 前端工程化的流程（架构选型、业务开发、测试、打包构建、部署上线、项目监控）

前端工程化的话，首先是工具的选择，比如是用什么框架，是用什么脚手架等等，然后是一个好的代码编辑器和一个好的开发环境，比如使用 vscode 插件来提升编码速度，使用 webpak 的 devserver 来提高开发环境下的构建速度，也可以使用一些 nobundle 类的打包工具，比如 vite，使用 HMR 来进一步提高开发中的效率，前后端交互中，数据往往有后端提供，为了提高开发的整体速度，前端可以显示 mock 的形式自己 mock 一份数据，这样前后端同时开发，等后端的接口开发完毕，就可以将 mock 数据提换成真实的数据，但我们开发完了一个项目，需要对现目进行打包，这时，可以通过 webpack 的一系列的优化打包的方案来对代码进行更好地打包，比如代码压缩，tree sharking 等等，最后是项目部书，可以引入自动化部署方案，比如 Jenkins

对于一些重复性比较高的，实现起来比较通用的页面可以使用低代码开发或无代码开发

开发效率方面除了传统的的前后端分离的开发方式，也可以会用前后端一体化的云开发

### Webpack 基本概念与配置

webpack 是一个打包工具，它借助 babel 具备编译代码的能力，比如将一些包含新特性的代码编译成浏览器所兼容的代码，能够将项目中一些散落的模块打包到一块，因为只有开发阶段才需要模块文件的划分，来帮我们更好地组织代码，借助 loader 机制可以支持各种类型的文件，比如图片，字体文件，样式文件都可以将其看作为一个模块，这样一来就有了一个统一的模块化方案

webpack4 的话又是那种打包模式，开发模式，生产模式，和 none 模式，none 模式进行最原始的打包，不做任何处理，前两种打包模式都会在一定程度上进行优化，production 模式下，启动内置优化插件，自动优化打包结果，打包速度偏慢，development 模式下，自动优化打包速度，添加一些调试过程中的辅助插件

### loader 与 plugin 原理与实现

每个 Webpack 的 Loader 都需要导出一个函数，这个函数就是我们这个 Loader 对资源的处理过程，它的输入就是加载到的资源文件内容，输出就是我们加工后的结果

Webpack 加载资源文件的过程类似于一个工作管道，你可以在这个过程中依次使用多个 Loader，但是最终这个管道结束过后的结果必须是一段标准的 JS 代码字符串

相比于 Loader，插件的能力范围更宽，因为 Loader 只是在模块的加载环节工作，而插件的作用范围几乎可以触及 Webpack 工作的每一个环节 webpack 的插件机制就是我们在软件开发中最常见的钩子机制,钩子机制也特别容易理解，它有点类似于 Web 中的事件。在 Webpack 整个工作过程会有很多环节，为了便于插件的扩展，Webpack 几乎在每一个环节都埋下了一个钩子。这样我们在开发插件的时候，通过往这些不同节点上挂载不同的任务，就可以轻松扩展 Webpack 的能力

Webpack 要求我们的插件必须是一个函数或者是一个包含 apply 方法的对象，一般我们都会定义一个对象，在这个对象中定义 apply 方法。然后在使用时，再通过这个对象来创建一个实例对象去使用这个插件

这个方法会在 Webpack 启动时被调用，它接收一个 compiler 对象参数，这个对象是 Webpack 工作过程中最核心的对象，里面包含了我们此次构建的所有配置信息，我们就是通过这个对象去注册钩子函数

### Webpack 的模块热替换及实现

[HMR](http://vhblog.ygjie.icu/zh/essay/41/#hot-module-replacement)

[HMR 原理解析](https://zhuanlan.zhihu.com/p/30669007)

### Webpack 的优化问题

构建优化，打包优化

### SPA 及其优缺点

**优点：**

1. 良好的交互体验,用户不需要重新刷新页面，获取数据也是通过 Ajax 异步获取，页面显示流畅。
2. 良好的前后端工作分离模式,单页 Web 应用可以和 RESTful 规约一起使用，通过 REST API 提供接口数据，并使用 Ajax 异步获取，这样有助于分离客户端和服务器端工作。更进一步，可以在客户端也可以分解为静态页面和页面交互两个部分。
3. 减轻服务器压力,服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；
4. 共用一套后端程序代码,不用修改后端程序代码就可以同时用于 Web 界面、手机、平板等多种客户端；

**缺点：**

1. SEO 难度较高,由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势，所以如果你的站点对 SEO 很看重，且要用单页应用，那么就做些静态页面给搜索引擎用吧。
2. 页面复杂都提高，复杂逻辑程度成倍,由于后端只提供数据而不再管前端的展示逻辑和页面合成，所以这些展示逻辑和页面合成都需要在前端进行编写（前进、后退等），所以会大大提高页面的复杂性和逻辑的难度
3. 初次加载耗时多,为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面可以在需要的时候加载。所以必须对 JavaScript 及 CSS 代码进行合并压缩处理，如果使用第三方库，建议使用一些大公司的 CDN，因此带宽的消耗是必然的

### SSR 实现及优缺点

**优点**

1. 更利于 SEO，服务端渲染返回给客户端的是已经获取了异步数据并执行 JavaScript 脚本的最终 HTML，网络爬中就可以抓取到完整页面的信息
2. 更利于首屏渲染，首屏的渲染是 node 发送过来的 html 字符串，并不依赖于 js 文件了，这就会使用户更快的看到页面的内容。尤其是针对大型单页应用，打包后文件体积比较大，普通客户端渲染加载所有所需文件时间较长，首页就会有一个很长的白屏等待时间

**缺点**

1. 服务端压力较大，本来是通过客户端完成渲染，现在统一到服务端 node 服务去做。尤其是高并发访问的情况，会大量占用服务端 CPU 资源
2. 开发条件受限，在服务端渲染中，只会执行到 componentDidMount 之前的生命周期钩子，因此项目引用的第三方的库也不可用其它生命周期钩子，这对引用库的选择产生了很大的限制；
3. 学习成本相对较高，除了对 webpack、React 要熟悉，还需要掌握 node、Koa2 等相关技术。相对于客户端渲染，项目构建、部署过程更加复杂。

## React

### React 自身特点及选型时考虑

React 官网对他的描述是 用于构建用户界面的 JavaScript 库，特点有声明式，组件化，一次学习，随处编写

声明式的优点在于直观，可以一做到一目了然，也便于组合

组件化的优势在降低系统间的耦合度，提高功能内部的聚合性，React 的组件化没有使用模板进行编写，而是使用了 JSX

通用性在于开发者不会直接操作 DOM，而是操作虚拟 DOM，这就使得 react 的开发不局限于 WEB，也建议是其他平台，比如 Native，VR，shell，只要是兼容虚拟 Dom 的都可以使用 React

react 的缺点的话是并没有提供一揽子的解决方法，只提供了视图层面的解决方案，想路由，状态管理，网络请求等都需要单独引入第三方库，react 生态下页提供了一揽子的解决方案，作为对 React 的补充

### React 与 VUE 的异同

### Virtual DOM

[😀](http://vhblog.ygjie.icu/zh/essay/28/)

### React 生命周期

[😀](http://vhblog.ygjie.icu/zh/essay/12/)

### Diff 算法

[😀](http://vhblog.ygjie.icu/zh/essay/29/)

### 受控组件与非受控组件

[😀](http://vhblog.ygjie.icu/zh/essay/15/#%E7%BB%84%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1)

### 高阶组件

[😀](http://vhblog.ygjie.icu/zh/essay/15/#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6)

### Flux 架构模式（涉及 MVC/MVVM、Flux）

[😀](http://vhblog.ygjie.icu/zh/essay/36/#%E8%AE%A4%E8%AF%86-flux-%E6%9E%B6%E6%9E%84)

### Redux 设计概念、设计原则、方法、redux 实现异步流的库

[😀](http://vhblog.ygjie.icu/zh/essay/36/#redux-%E5%85%B3%E9%94%AE%E8%A6%81%E7%B4%A0%E4%B8%8E%E5%B7%A5%E4%BD%9C%E6%B5%81)

### 纯组件（Pure Component）与 shouldComponentUpdate 关系

[😀](http://vhblog.ygjie.icu/zh/essay/12/#updating-%E9%98%B6%E6%AE%B5-%E7%BB%84%E4%BB%B6%E7%9A%84%E6%9B%B4%E6%96%B0)

### Redux 中的<Provider/>组件与 connect 函数

[😀](https://blog.csdn.net/q1056843325/article/details/54880804)

### React Fiber 架构

[😀](http://vhblog.ygjie.icu/zh/essay/34/#fiber-%E8%B0%83%E5%92%8C)

### React Hooks 的作用及原理

[😀](http://vhblog.ygjie.icu/zh/essay/32/)

## NodeJs

### NodeJS基本概念与特点

官网：Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时

+ Node.js是一个 JavaScript 运行环境，依赖于 Chrome V8 引擎进行代码解释
+ 事件驱动：在 Node 中，客户端请求建立连接，提交数据等行为，会触发相应的事件。在 Node 中，在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件，然后返回继续执行原事件的回调函数
+ 非阻塞 I/O：Node.js 中采用了非阻塞型 I/O 机制，在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中，从而提高了程序的执行效率
+ 轻量可伸缩，适用于实时数据交互应用
+ 单线程：好处是减少内存开销，不用像多线程编程那样处处在意状态同步的问题。缺点是错误会引起整个应用退出

**nodejs应用场景**

Node.js 擅长处理 I/O，不善于计算（单线程的缺点），因此 Node.js 适用于：当应用程序需要处理大量并发的 I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js 也非常适合与 web socket 配合，开发长连接的实时交互应用程序。比如：聊天室，博客系统，考试系统等


### CommonJS规范、核心模块

规范的内容：

**定义模块**

根据CommonJS规范，一个单独的文件就是一个模块，每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性

**模块输出**

模块只有一个出口，module.exports对象，需要把模块希望输出的内容放入该对象

**加载模块**

加载模块使用require方法，该方法读取一个文件并执行，返回文件内部的module.exports对象

由于上面的CommonJS规范中的require是同步的，模块系统需要同步读取模块文件内容，并编译执行以得到模块接口，这在服务器端实现很简单，但是由于js脚本天生异步，因此在浏览器端实现问题会很多，所以在浏览器中不使用commonjs


### Node的异步I/O

node的异步I/O不等于非阻塞I/O。非阻塞I/O调用后虽然也是立即返回，但是应用层会不断的重复I/O操作去轮询系统是否完成数据读取，让CPU处理状态判断，对CPU造成资源的浪费。

然而在异步I/O里，基于多子线程的方式去解决了非阻塞I/O的问题，应用层(主线程)发起I/O请求后，就不再过问情况了。然后让子线程来完成数据获取，当读写完成后通知主线程

[NodeJS 异步I/O详解](https://zhuanlan.zhihu.com/p/93289115)

### Node的内存控制

[node内存控制](https://www.jianshu.com/p/71a999baafbb)

### Node构建网络服务（TCP、HTTP、Web Socket服务等）

Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端

[搭建 HTTP 服务器](http://nodejs.cn/learn/build-an-http-server)

[使用 Node.js 发送 HTTP 请求](http://nodejs.cn/learn/making-http-requests-with-nodejs)

[使用 Node.js 发送 HTTP POST 请求](http://nodejs.cn/learn/make-an-http-post-request-using-nodejs)

[使用 Node.js 获取 HTTP 请求的正文数据](http://nodejs.cn/learn/get-http-request-body-data-using-nodejs)

### Node的进程

[深入理解Node.js 进程与线程](https://blog.csdn.net/xgangzai/article/details/98919412)
